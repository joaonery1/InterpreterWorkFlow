
/*********************************************************************
***                                                                 ***
***  Source code generated by cl2cpp.pl                             ***
***                                                                 ***
***  Please do not edit                                             ***
***                                                                 ***
*********************************************************************/

#include "vglImage.h"
#include "vglClImage.h"
#include "vglContext.h"

#include "vglShape.h"
#include "vglClShape.h"

#include "vglStrEl.h"
#include "vglClStrEl.h"

#include <fstream>

extern VglClContext cl;

/** Erosion of src image by mask. Result is stored in dst image.

  */
void vglCl3dFuzzyAlgDilate(VglImage* img_input, VglImage* img_output, float* convolution_window, int window_size_x, int window_size_y, int window_size_z)
{
  vglCheckContext(img_input, VGL_CL_CONTEXT);
  vglCheckContext(img_output, VGL_CL_CONTEXT);

  cl_int _err;

  cl_mem mobj_convolution_window = NULL;
  mobj_convolution_window = clCreateBuffer(cl.context, CL_MEM_READ_ONLY, (window_size_x*window_size_y*window_size_z)*sizeof(float), NULL, &_err);
  vglClCheckError( _err, (char*) "clCreateBuffer convolution_window" );
  _err = clEnqueueWriteBuffer(cl.commandQueue, mobj_convolution_window, CL_TRUE, 0, (window_size_x*window_size_y*window_size_z)*sizeof(float), convolution_window, 0, NULL, NULL);
  vglClCheckError( _err, (char*) "clEnqueueWriteBuffer convolution_window" );

  static cl_program _program = NULL;
  if (_program == NULL)
  {
    char* _file_path = (char*) "CL_MM/vglCl3dFuzzyAlgDilate.cl";
    printf("Compiling %s\n", _file_path);
    std::ifstream _file(_file_path);
    if(_file.fail())
    {
      fprintf(stderr, "%s:%s: Error: File %s not found.\n", __FILE__, __FUNCTION__, _file_path);
      exit(1);
    }
    std::string _prog( std::istreambuf_iterator<char>( _file ), ( std::istreambuf_iterator<char>() ) );
    const char *_source_str = _prog.c_str();
#ifdef __DEBUG__
    printf("Kernel to be compiled:\n%s\n", _source_str);
#endif
    _program = clCreateProgramWithSource(cl.context, 1, (const char **) &_source_str, 0, &_err );
    vglClCheckError(_err, (char*) "clCreateProgramWithSource" );
    _err = clBuildProgram(_program, 1, cl.deviceId, "-I CL_MM/", NULL, NULL );
    vglClBuildDebug(_err, _program);
  }

  static cl_kernel _kernel = NULL;
  if (_kernel == NULL)
  {
    _kernel = clCreateKernel( _program, "vglCl3dFuzzyAlgDilate", &_err );
    vglClCheckError(_err, (char*) "clCreateKernel" );
  }


  _err = clSetKernelArg( _kernel, 0, sizeof( cl_mem ), (void*) &img_input->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 0" );

  _err = clSetKernelArg( _kernel, 1, sizeof( cl_mem ), (void*) &img_output->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 1" );

  _err = clSetKernelArg( _kernel, 2, sizeof( cl_mem ), (float*) &mobj_convolution_window );
  vglClCheckError( _err, (char*) "clSetKernelArg 2" );

  _err = clSetKernelArg( _kernel, 3, sizeof( int ), &window_size_x );
  vglClCheckError( _err, (char*) "clSetKernelArg 3" );

  _err = clSetKernelArg( _kernel, 4, sizeof( int ), &window_size_y );
  vglClCheckError( _err, (char*) "clSetKernelArg 4" );

  _err = clSetKernelArg( _kernel, 5, sizeof( int ), &window_size_z );
  vglClCheckError( _err, (char*) "clSetKernelArg 5" );

  int _ndim = 2;
  if (img_input->ndim > 2){
    _ndim = 3;
  }

  size_t _worksize_0 = img_input->getWidthIn();
  if (img_input->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_input->getWidthStep();
  }
  if (img_output->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_output->getWidthStep();
  }

  size_t worksize[] = { _worksize_0, img_input->getHeightIn(),  img_input->getNFrames() };
  clEnqueueNDRangeKernel( cl.commandQueue, _kernel, _ndim, NULL, worksize, 0, 0, 0, 0 );

  vglClCheckError( _err, (char*) "clEnqueueNDRangeKernel" );

  _err = clReleaseMemObject( mobj_convolution_window );
  vglClCheckError(_err, (char*) "clReleaseMemObject mobj_convolution_window");

  vglSetContext(img_output, VGL_CL_CONTEXT);
}

/** Erosion of src image by mask. Result is stored in dst image.

  */
void vglCl3dFuzzyAlgErode(VglImage* img_input, VglImage* img_output, float* convolution_window, int window_size_x, int window_size_y, int window_size_z)
{
  vglCheckContext(img_input, VGL_CL_CONTEXT);
  vglCheckContext(img_output, VGL_CL_CONTEXT);

  cl_int _err;

  cl_mem mobj_convolution_window = NULL;
  mobj_convolution_window = clCreateBuffer(cl.context, CL_MEM_READ_ONLY, (window_size_x*window_size_y*window_size_z)*sizeof(float), NULL, &_err);
  vglClCheckError( _err, (char*) "clCreateBuffer convolution_window" );
  _err = clEnqueueWriteBuffer(cl.commandQueue, mobj_convolution_window, CL_TRUE, 0, (window_size_x*window_size_y*window_size_z)*sizeof(float), convolution_window, 0, NULL, NULL);
  vglClCheckError( _err, (char*) "clEnqueueWriteBuffer convolution_window" );

  static cl_program _program = NULL;
  if (_program == NULL)
  {
    char* _file_path = (char*) "CL_MM/vglCl3dFuzzyAlgErode.cl";
    printf("Compiling %s\n", _file_path);
    std::ifstream _file(_file_path);
    if(_file.fail())
    {
      fprintf(stderr, "%s:%s: Error: File %s not found.\n", __FILE__, __FUNCTION__, _file_path);
      exit(1);
    }
    std::string _prog( std::istreambuf_iterator<char>( _file ), ( std::istreambuf_iterator<char>() ) );
    const char *_source_str = _prog.c_str();
#ifdef __DEBUG__
    printf("Kernel to be compiled:\n%s\n", _source_str);
#endif
    _program = clCreateProgramWithSource(cl.context, 1, (const char **) &_source_str, 0, &_err );
    vglClCheckError(_err, (char*) "clCreateProgramWithSource" );
    _err = clBuildProgram(_program, 1, cl.deviceId, "-I CL_MM/", NULL, NULL );
    vglClBuildDebug(_err, _program);
  }

  static cl_kernel _kernel = NULL;
  if (_kernel == NULL)
  {
    _kernel = clCreateKernel( _program, "vglCl3dFuzzyAlgErode", &_err );
    vglClCheckError(_err, (char*) "clCreateKernel" );
  }


  _err = clSetKernelArg( _kernel, 0, sizeof( cl_mem ), (void*) &img_input->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 0" );

  _err = clSetKernelArg( _kernel, 1, sizeof( cl_mem ), (void*) &img_output->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 1" );

  _err = clSetKernelArg( _kernel, 2, sizeof( cl_mem ), (float*) &mobj_convolution_window );
  vglClCheckError( _err, (char*) "clSetKernelArg 2" );

  _err = clSetKernelArg( _kernel, 3, sizeof( int ), &window_size_x );
  vglClCheckError( _err, (char*) "clSetKernelArg 3" );

  _err = clSetKernelArg( _kernel, 4, sizeof( int ), &window_size_y );
  vglClCheckError( _err, (char*) "clSetKernelArg 4" );

  _err = clSetKernelArg( _kernel, 5, sizeof( int ), &window_size_z );
  vglClCheckError( _err, (char*) "clSetKernelArg 5" );

  int _ndim = 2;
  if (img_input->ndim > 2){
    _ndim = 3;
  }

  size_t _worksize_0 = img_input->getWidthIn();
  if (img_input->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_input->getWidthStep();
  }
  if (img_output->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_output->getWidthStep();
  }

  size_t worksize[] = { _worksize_0, img_input->getHeightIn(),  img_input->getNFrames() };
  clEnqueueNDRangeKernel( cl.commandQueue, _kernel, _ndim, NULL, worksize, 0, 0, 0, 0 );

  vglClCheckError( _err, (char*) "clEnqueueNDRangeKernel" );

  _err = clReleaseMemObject( mobj_convolution_window );
  vglClCheckError(_err, (char*) "clReleaseMemObject mobj_convolution_window");

  vglSetContext(img_output, VGL_CL_CONTEXT);
}

/** Erosion of src image by mask. Result is stored in dst image.

  */
void vglCl3dFuzzyArithDilate(VglImage* img_input, VglImage* img_output, float* convolution_window, int window_size_x, int window_size_y, int window_size_z)
{
  vglCheckContext(img_input, VGL_CL_CONTEXT);
  vglCheckContext(img_output, VGL_CL_CONTEXT);

  cl_int _err;

  cl_mem mobj_convolution_window = NULL;
  mobj_convolution_window = clCreateBuffer(cl.context, CL_MEM_READ_ONLY, (window_size_x*window_size_y*window_size_z)*sizeof(float), NULL, &_err);
  vglClCheckError( _err, (char*) "clCreateBuffer convolution_window" );
  _err = clEnqueueWriteBuffer(cl.commandQueue, mobj_convolution_window, CL_TRUE, 0, (window_size_x*window_size_y*window_size_z)*sizeof(float), convolution_window, 0, NULL, NULL);
  vglClCheckError( _err, (char*) "clEnqueueWriteBuffer convolution_window" );

  static cl_program _program = NULL;
  if (_program == NULL)
  {
    char* _file_path = (char*) "CL_MM/vglCl3dFuzzyArithDilate.cl";
    printf("Compiling %s\n", _file_path);
    std::ifstream _file(_file_path);
    if(_file.fail())
    {
      fprintf(stderr, "%s:%s: Error: File %s not found.\n", __FILE__, __FUNCTION__, _file_path);
      exit(1);
    }
    std::string _prog( std::istreambuf_iterator<char>( _file ), ( std::istreambuf_iterator<char>() ) );
    const char *_source_str = _prog.c_str();
#ifdef __DEBUG__
    printf("Kernel to be compiled:\n%s\n", _source_str);
#endif
    _program = clCreateProgramWithSource(cl.context, 1, (const char **) &_source_str, 0, &_err );
    vglClCheckError(_err, (char*) "clCreateProgramWithSource" );
    _err = clBuildProgram(_program, 1, cl.deviceId, "-I CL_MM/", NULL, NULL );
    vglClBuildDebug(_err, _program);
  }

  static cl_kernel _kernel = NULL;
  if (_kernel == NULL)
  {
    _kernel = clCreateKernel( _program, "vglCl3dFuzzyArithDilate", &_err );
    vglClCheckError(_err, (char*) "clCreateKernel" );
  }


  _err = clSetKernelArg( _kernel, 0, sizeof( cl_mem ), (void*) &img_input->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 0" );

  _err = clSetKernelArg( _kernel, 1, sizeof( cl_mem ), (void*) &img_output->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 1" );

  _err = clSetKernelArg( _kernel, 2, sizeof( cl_mem ), (float*) &mobj_convolution_window );
  vglClCheckError( _err, (char*) "clSetKernelArg 2" );

  _err = clSetKernelArg( _kernel, 3, sizeof( int ), &window_size_x );
  vglClCheckError( _err, (char*) "clSetKernelArg 3" );

  _err = clSetKernelArg( _kernel, 4, sizeof( int ), &window_size_y );
  vglClCheckError( _err, (char*) "clSetKernelArg 4" );

  _err = clSetKernelArg( _kernel, 5, sizeof( int ), &window_size_z );
  vglClCheckError( _err, (char*) "clSetKernelArg 5" );

  int _ndim = 2;
  if (img_input->ndim > 2){
    _ndim = 3;
  }

  size_t _worksize_0 = img_input->getWidthIn();
  if (img_input->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_input->getWidthStep();
  }
  if (img_output->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_output->getWidthStep();
  }

  size_t worksize[] = { _worksize_0, img_input->getHeightIn(),  img_input->getNFrames() };
  clEnqueueNDRangeKernel( cl.commandQueue, _kernel, _ndim, NULL, worksize, 0, 0, 0, 0 );

  vglClCheckError( _err, (char*) "clEnqueueNDRangeKernel" );

  _err = clReleaseMemObject( mobj_convolution_window );
  vglClCheckError(_err, (char*) "clReleaseMemObject mobj_convolution_window");

  vglSetContext(img_output, VGL_CL_CONTEXT);
}

/** Erosion of src image by mask. Result is stored in dst image.

  */
void vglCl3dFuzzyArithErode(VglImage* img_input, VglImage* img_output, float* convolution_window, int window_size_x, int window_size_y, int window_size_z)
{
  vglCheckContext(img_input, VGL_CL_CONTEXT);
  vglCheckContext(img_output, VGL_CL_CONTEXT);

  cl_int _err;

  cl_mem mobj_convolution_window = NULL;
  mobj_convolution_window = clCreateBuffer(cl.context, CL_MEM_READ_ONLY, (window_size_x*window_size_y*window_size_z)*sizeof(float), NULL, &_err);
  vglClCheckError( _err, (char*) "clCreateBuffer convolution_window" );
  _err = clEnqueueWriteBuffer(cl.commandQueue, mobj_convolution_window, CL_TRUE, 0, (window_size_x*window_size_y*window_size_z)*sizeof(float), convolution_window, 0, NULL, NULL);
  vglClCheckError( _err, (char*) "clEnqueueWriteBuffer convolution_window" );

  static cl_program _program = NULL;
  if (_program == NULL)
  {
    char* _file_path = (char*) "CL_MM/vglCl3dFuzzyArithErode.cl";
    printf("Compiling %s\n", _file_path);
    std::ifstream _file(_file_path);
    if(_file.fail())
    {
      fprintf(stderr, "%s:%s: Error: File %s not found.\n", __FILE__, __FUNCTION__, _file_path);
      exit(1);
    }
    std::string _prog( std::istreambuf_iterator<char>( _file ), ( std::istreambuf_iterator<char>() ) );
    const char *_source_str = _prog.c_str();
#ifdef __DEBUG__
    printf("Kernel to be compiled:\n%s\n", _source_str);
#endif
    _program = clCreateProgramWithSource(cl.context, 1, (const char **) &_source_str, 0, &_err );
    vglClCheckError(_err, (char*) "clCreateProgramWithSource" );
    _err = clBuildProgram(_program, 1, cl.deviceId, "-I CL_MM/", NULL, NULL );
    vglClBuildDebug(_err, _program);
  }

  static cl_kernel _kernel = NULL;
  if (_kernel == NULL)
  {
    _kernel = clCreateKernel( _program, "vglCl3dFuzzyArithErode", &_err );
    vglClCheckError(_err, (char*) "clCreateKernel" );
  }


  _err = clSetKernelArg( _kernel, 0, sizeof( cl_mem ), (void*) &img_input->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 0" );

  _err = clSetKernelArg( _kernel, 1, sizeof( cl_mem ), (void*) &img_output->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 1" );

  _err = clSetKernelArg( _kernel, 2, sizeof( cl_mem ), (float*) &mobj_convolution_window );
  vglClCheckError( _err, (char*) "clSetKernelArg 2" );

  _err = clSetKernelArg( _kernel, 3, sizeof( int ), &window_size_x );
  vglClCheckError( _err, (char*) "clSetKernelArg 3" );

  _err = clSetKernelArg( _kernel, 4, sizeof( int ), &window_size_y );
  vglClCheckError( _err, (char*) "clSetKernelArg 4" );

  _err = clSetKernelArg( _kernel, 5, sizeof( int ), &window_size_z );
  vglClCheckError( _err, (char*) "clSetKernelArg 5" );

  int _ndim = 2;
  if (img_input->ndim > 2){
    _ndim = 3;
  }

  size_t _worksize_0 = img_input->getWidthIn();
  if (img_input->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_input->getWidthStep();
  }
  if (img_output->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_output->getWidthStep();
  }

  size_t worksize[] = { _worksize_0, img_input->getHeightIn(),  img_input->getNFrames() };
  clEnqueueNDRangeKernel( cl.commandQueue, _kernel, _ndim, NULL, worksize, 0, 0, 0, 0 );

  vglClCheckError( _err, (char*) "clEnqueueNDRangeKernel" );

  _err = clReleaseMemObject( mobj_convolution_window );
  vglClCheckError(_err, (char*) "clReleaseMemObject mobj_convolution_window");

  vglSetContext(img_output, VGL_CL_CONTEXT);
}

/** Erosion of src image by mask. Result is stored in dst image.

  */
void vglCl3dFuzzyBoundDilate(VglImage* img_input, VglImage* img_output, float* convolution_window, int window_size_x, int window_size_y, int window_size_z)
{
  vglCheckContext(img_input, VGL_CL_CONTEXT);
  vglCheckContext(img_output, VGL_CL_CONTEXT);

  cl_int _err;

  cl_mem mobj_convolution_window = NULL;
  mobj_convolution_window = clCreateBuffer(cl.context, CL_MEM_READ_ONLY, (window_size_x*window_size_y*window_size_z)*sizeof(float), NULL, &_err);
  vglClCheckError( _err, (char*) "clCreateBuffer convolution_window" );
  _err = clEnqueueWriteBuffer(cl.commandQueue, mobj_convolution_window, CL_TRUE, 0, (window_size_x*window_size_y*window_size_z)*sizeof(float), convolution_window, 0, NULL, NULL);
  vglClCheckError( _err, (char*) "clEnqueueWriteBuffer convolution_window" );

  static cl_program _program = NULL;
  if (_program == NULL)
  {
    char* _file_path = (char*) "CL_MM/vglCl3dFuzzyBoundDilate.cl";
    printf("Compiling %s\n", _file_path);
    std::ifstream _file(_file_path);
    if(_file.fail())
    {
      fprintf(stderr, "%s:%s: Error: File %s not found.\n", __FILE__, __FUNCTION__, _file_path);
      exit(1);
    }
    std::string _prog( std::istreambuf_iterator<char>( _file ), ( std::istreambuf_iterator<char>() ) );
    const char *_source_str = _prog.c_str();
#ifdef __DEBUG__
    printf("Kernel to be compiled:\n%s\n", _source_str);
#endif
    _program = clCreateProgramWithSource(cl.context, 1, (const char **) &_source_str, 0, &_err );
    vglClCheckError(_err, (char*) "clCreateProgramWithSource" );
    _err = clBuildProgram(_program, 1, cl.deviceId, "-I CL_MM/", NULL, NULL );
    vglClBuildDebug(_err, _program);
  }

  static cl_kernel _kernel = NULL;
  if (_kernel == NULL)
  {
    _kernel = clCreateKernel( _program, "vglCl3dFuzzyBoundDilate", &_err );
    vglClCheckError(_err, (char*) "clCreateKernel" );
  }


  _err = clSetKernelArg( _kernel, 0, sizeof( cl_mem ), (void*) &img_input->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 0" );

  _err = clSetKernelArg( _kernel, 1, sizeof( cl_mem ), (void*) &img_output->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 1" );

  _err = clSetKernelArg( _kernel, 2, sizeof( cl_mem ), (float*) &mobj_convolution_window );
  vglClCheckError( _err, (char*) "clSetKernelArg 2" );

  _err = clSetKernelArg( _kernel, 3, sizeof( int ), &window_size_x );
  vglClCheckError( _err, (char*) "clSetKernelArg 3" );

  _err = clSetKernelArg( _kernel, 4, sizeof( int ), &window_size_y );
  vglClCheckError( _err, (char*) "clSetKernelArg 4" );

  _err = clSetKernelArg( _kernel, 5, sizeof( int ), &window_size_z );
  vglClCheckError( _err, (char*) "clSetKernelArg 5" );

  int _ndim = 2;
  if (img_input->ndim > 2){
    _ndim = 3;
  }

  size_t _worksize_0 = img_input->getWidthIn();
  if (img_input->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_input->getWidthStep();
  }
  if (img_output->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_output->getWidthStep();
  }

  size_t worksize[] = { _worksize_0, img_input->getHeightIn(),  img_input->getNFrames() };
  clEnqueueNDRangeKernel( cl.commandQueue, _kernel, _ndim, NULL, worksize, 0, 0, 0, 0 );

  vglClCheckError( _err, (char*) "clEnqueueNDRangeKernel" );

  _err = clReleaseMemObject( mobj_convolution_window );
  vglClCheckError(_err, (char*) "clReleaseMemObject mobj_convolution_window");

  vglSetContext(img_output, VGL_CL_CONTEXT);
}

/** Erosion of src image by mask. Result is stored in dst image.

  */
void vglCl3dFuzzyBoundErode(VglImage* img_input, VglImage* img_output, float* convolution_window, int window_size_x, int window_size_y, int window_size_z)
{
  vglCheckContext(img_input, VGL_CL_CONTEXT);
  vglCheckContext(img_output, VGL_CL_CONTEXT);

  cl_int _err;

  cl_mem mobj_convolution_window = NULL;
  mobj_convolution_window = clCreateBuffer(cl.context, CL_MEM_READ_ONLY, (window_size_x*window_size_y*window_size_z)*sizeof(float), NULL, &_err);
  vglClCheckError( _err, (char*) "clCreateBuffer convolution_window" );
  _err = clEnqueueWriteBuffer(cl.commandQueue, mobj_convolution_window, CL_TRUE, 0, (window_size_x*window_size_y*window_size_z)*sizeof(float), convolution_window, 0, NULL, NULL);
  vglClCheckError( _err, (char*) "clEnqueueWriteBuffer convolution_window" );

  static cl_program _program = NULL;
  if (_program == NULL)
  {
    char* _file_path = (char*) "CL_MM/vglCl3dFuzzyBoundErode.cl";
    printf("Compiling %s\n", _file_path);
    std::ifstream _file(_file_path);
    if(_file.fail())
    {
      fprintf(stderr, "%s:%s: Error: File %s not found.\n", __FILE__, __FUNCTION__, _file_path);
      exit(1);
    }
    std::string _prog( std::istreambuf_iterator<char>( _file ), ( std::istreambuf_iterator<char>() ) );
    const char *_source_str = _prog.c_str();
#ifdef __DEBUG__
    printf("Kernel to be compiled:\n%s\n", _source_str);
#endif
    _program = clCreateProgramWithSource(cl.context, 1, (const char **) &_source_str, 0, &_err );
    vglClCheckError(_err, (char*) "clCreateProgramWithSource" );
    _err = clBuildProgram(_program, 1, cl.deviceId, "-I CL_MM/", NULL, NULL );
    vglClBuildDebug(_err, _program);
  }

  static cl_kernel _kernel = NULL;
  if (_kernel == NULL)
  {
    _kernel = clCreateKernel( _program, "vglCl3dFuzzyBoundErode", &_err );
    vglClCheckError(_err, (char*) "clCreateKernel" );
  }


  _err = clSetKernelArg( _kernel, 0, sizeof( cl_mem ), (void*) &img_input->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 0" );

  _err = clSetKernelArg( _kernel, 1, sizeof( cl_mem ), (void*) &img_output->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 1" );

  _err = clSetKernelArg( _kernel, 2, sizeof( cl_mem ), (float*) &mobj_convolution_window );
  vglClCheckError( _err, (char*) "clSetKernelArg 2" );

  _err = clSetKernelArg( _kernel, 3, sizeof( int ), &window_size_x );
  vglClCheckError( _err, (char*) "clSetKernelArg 3" );

  _err = clSetKernelArg( _kernel, 4, sizeof( int ), &window_size_y );
  vglClCheckError( _err, (char*) "clSetKernelArg 4" );

  _err = clSetKernelArg( _kernel, 5, sizeof( int ), &window_size_z );
  vglClCheckError( _err, (char*) "clSetKernelArg 5" );

  int _ndim = 2;
  if (img_input->ndim > 2){
    _ndim = 3;
  }

  size_t _worksize_0 = img_input->getWidthIn();
  if (img_input->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_input->getWidthStep();
  }
  if (img_output->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_output->getWidthStep();
  }

  size_t worksize[] = { _worksize_0, img_input->getHeightIn(),  img_input->getNFrames() };
  clEnqueueNDRangeKernel( cl.commandQueue, _kernel, _ndim, NULL, worksize, 0, 0, 0, 0 );

  vglClCheckError( _err, (char*) "clEnqueueNDRangeKernel" );

  _err = clReleaseMemObject( mobj_convolution_window );
  vglClCheckError(_err, (char*) "clReleaseMemObject mobj_convolution_window");

  vglSetContext(img_output, VGL_CL_CONTEXT);
}

/** Erosion of src image by mask. Result is stored in dst image.

  */
void vglCl3dFuzzyDaPDilate(VglImage* img_input, VglImage* img_output, float* convolution_window, int window_size_x, int window_size_y, int window_size_z, float gama)
{
  vglCheckContext(img_input, VGL_CL_CONTEXT);
  vglCheckContext(img_output, VGL_CL_CONTEXT);

  cl_int _err;

  cl_mem mobj_convolution_window = NULL;
  mobj_convolution_window = clCreateBuffer(cl.context, CL_MEM_READ_ONLY, (window_size_x*window_size_y*window_size_z)*sizeof(float), NULL, &_err);
  vglClCheckError( _err, (char*) "clCreateBuffer convolution_window" );
  _err = clEnqueueWriteBuffer(cl.commandQueue, mobj_convolution_window, CL_TRUE, 0, (window_size_x*window_size_y*window_size_z)*sizeof(float), convolution_window, 0, NULL, NULL);
  vglClCheckError( _err, (char*) "clEnqueueWriteBuffer convolution_window" );

  static cl_program _program = NULL;
  if (_program == NULL)
  {
    char* _file_path = (char*) "CL_MM/vglCl3dFuzzyDaPDilate.cl";
    printf("Compiling %s\n", _file_path);
    std::ifstream _file(_file_path);
    if(_file.fail())
    {
      fprintf(stderr, "%s:%s: Error: File %s not found.\n", __FILE__, __FUNCTION__, _file_path);
      exit(1);
    }
    std::string _prog( std::istreambuf_iterator<char>( _file ), ( std::istreambuf_iterator<char>() ) );
    const char *_source_str = _prog.c_str();
#ifdef __DEBUG__
    printf("Kernel to be compiled:\n%s\n", _source_str);
#endif
    _program = clCreateProgramWithSource(cl.context, 1, (const char **) &_source_str, 0, &_err );
    vglClCheckError(_err, (char*) "clCreateProgramWithSource" );
    _err = clBuildProgram(_program, 1, cl.deviceId, "-I CL_MM/", NULL, NULL );
    vglClBuildDebug(_err, _program);
  }

  static cl_kernel _kernel = NULL;
  if (_kernel == NULL)
  {
    _kernel = clCreateKernel( _program, "vglCl3dFuzzyDaPDilate", &_err );
    vglClCheckError(_err, (char*) "clCreateKernel" );
  }


  _err = clSetKernelArg( _kernel, 0, sizeof( cl_mem ), (void*) &img_input->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 0" );

  _err = clSetKernelArg( _kernel, 1, sizeof( cl_mem ), (void*) &img_output->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 1" );

  _err = clSetKernelArg( _kernel, 2, sizeof( cl_mem ), (float*) &mobj_convolution_window );
  vglClCheckError( _err, (char*) "clSetKernelArg 2" );

  _err = clSetKernelArg( _kernel, 3, sizeof( int ), &window_size_x );
  vglClCheckError( _err, (char*) "clSetKernelArg 3" );

  _err = clSetKernelArg( _kernel, 4, sizeof( int ), &window_size_y );
  vglClCheckError( _err, (char*) "clSetKernelArg 4" );

  _err = clSetKernelArg( _kernel, 5, sizeof( int ), &window_size_z );
  vglClCheckError( _err, (char*) "clSetKernelArg 5" );

  _err = clSetKernelArg( _kernel, 6, sizeof( float ), &gama );
  vglClCheckError( _err, (char*) "clSetKernelArg 6" );

  int _ndim = 2;
  if (img_input->ndim > 2){
    _ndim = 3;
  }

  size_t _worksize_0 = img_input->getWidthIn();
  if (img_input->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_input->getWidthStep();
  }
  if (img_output->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_output->getWidthStep();
  }

  size_t worksize[] = { _worksize_0, img_input->getHeightIn(),  img_input->getNFrames() };
  clEnqueueNDRangeKernel( cl.commandQueue, _kernel, _ndim, NULL, worksize, 0, 0, 0, 0 );

  vglClCheckError( _err, (char*) "clEnqueueNDRangeKernel" );

  _err = clReleaseMemObject( mobj_convolution_window );
  vglClCheckError(_err, (char*) "clReleaseMemObject mobj_convolution_window");

  vglSetContext(img_output, VGL_CL_CONTEXT);
}

/** Erosion of src image by mask. Result is stored in dst image.

  */
void vglCl3dFuzzyDaPErode(VglImage* img_input, VglImage* img_output, float* convolution_window, int window_size_x, int window_size_y, int window_size_z, float gama)
{
  vglCheckContext(img_input, VGL_CL_CONTEXT);
  vglCheckContext(img_output, VGL_CL_CONTEXT);

  cl_int _err;

  cl_mem mobj_convolution_window = NULL;
  mobj_convolution_window = clCreateBuffer(cl.context, CL_MEM_READ_ONLY, (window_size_x*window_size_y*window_size_z)*sizeof(float), NULL, &_err);
  vglClCheckError( _err, (char*) "clCreateBuffer convolution_window" );
  _err = clEnqueueWriteBuffer(cl.commandQueue, mobj_convolution_window, CL_TRUE, 0, (window_size_x*window_size_y*window_size_z)*sizeof(float), convolution_window, 0, NULL, NULL);
  vglClCheckError( _err, (char*) "clEnqueueWriteBuffer convolution_window" );

  static cl_program _program = NULL;
  if (_program == NULL)
  {
    char* _file_path = (char*) "CL_MM/vglCl3dFuzzyDaPErode.cl";
    printf("Compiling %s\n", _file_path);
    std::ifstream _file(_file_path);
    if(_file.fail())
    {
      fprintf(stderr, "%s:%s: Error: File %s not found.\n", __FILE__, __FUNCTION__, _file_path);
      exit(1);
    }
    std::string _prog( std::istreambuf_iterator<char>( _file ), ( std::istreambuf_iterator<char>() ) );
    const char *_source_str = _prog.c_str();
#ifdef __DEBUG__
    printf("Kernel to be compiled:\n%s\n", _source_str);
#endif
    _program = clCreateProgramWithSource(cl.context, 1, (const char **) &_source_str, 0, &_err );
    vglClCheckError(_err, (char*) "clCreateProgramWithSource" );
    _err = clBuildProgram(_program, 1, cl.deviceId, "-I CL_MM/", NULL, NULL );
    vglClBuildDebug(_err, _program);
  }

  static cl_kernel _kernel = NULL;
  if (_kernel == NULL)
  {
    _kernel = clCreateKernel( _program, "vglCl3dFuzzyDaPErode", &_err );
    vglClCheckError(_err, (char*) "clCreateKernel" );
  }


  _err = clSetKernelArg( _kernel, 0, sizeof( cl_mem ), (void*) &img_input->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 0" );

  _err = clSetKernelArg( _kernel, 1, sizeof( cl_mem ), (void*) &img_output->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 1" );

  _err = clSetKernelArg( _kernel, 2, sizeof( cl_mem ), (float*) &mobj_convolution_window );
  vglClCheckError( _err, (char*) "clSetKernelArg 2" );

  _err = clSetKernelArg( _kernel, 3, sizeof( int ), &window_size_x );
  vglClCheckError( _err, (char*) "clSetKernelArg 3" );

  _err = clSetKernelArg( _kernel, 4, sizeof( int ), &window_size_y );
  vglClCheckError( _err, (char*) "clSetKernelArg 4" );

  _err = clSetKernelArg( _kernel, 5, sizeof( int ), &window_size_z );
  vglClCheckError( _err, (char*) "clSetKernelArg 5" );

  _err = clSetKernelArg( _kernel, 6, sizeof( float ), &gama );
  vglClCheckError( _err, (char*) "clSetKernelArg 6" );

  int _ndim = 2;
  if (img_input->ndim > 2){
    _ndim = 3;
  }

  size_t _worksize_0 = img_input->getWidthIn();
  if (img_input->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_input->getWidthStep();
  }
  if (img_output->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_output->getWidthStep();
  }

  size_t worksize[] = { _worksize_0, img_input->getHeightIn(),  img_input->getNFrames() };
  clEnqueueNDRangeKernel( cl.commandQueue, _kernel, _ndim, NULL, worksize, 0, 0, 0, 0 );

  vglClCheckError( _err, (char*) "clEnqueueNDRangeKernel" );

  _err = clReleaseMemObject( mobj_convolution_window );
  vglClCheckError(_err, (char*) "clReleaseMemObject mobj_convolution_window");

  vglSetContext(img_output, VGL_CL_CONTEXT);
}

/** Erosion of src image by mask. Result is stored in dst image.

  */
void vglCl3dFuzzyDrasticDilate(VglImage* img_input, VglImage* img_output, float* convolution_window, int window_size_x, int window_size_y, int window_size_z)
{
  vglCheckContext(img_input, VGL_CL_CONTEXT);
  vglCheckContext(img_output, VGL_CL_CONTEXT);

  cl_int _err;

  cl_mem mobj_convolution_window = NULL;
  mobj_convolution_window = clCreateBuffer(cl.context, CL_MEM_READ_ONLY, (window_size_x*window_size_y*window_size_z)*sizeof(float), NULL, &_err);
  vglClCheckError( _err, (char*) "clCreateBuffer convolution_window" );
  _err = clEnqueueWriteBuffer(cl.commandQueue, mobj_convolution_window, CL_TRUE, 0, (window_size_x*window_size_y*window_size_z)*sizeof(float), convolution_window, 0, NULL, NULL);
  vglClCheckError( _err, (char*) "clEnqueueWriteBuffer convolution_window" );

  static cl_program _program = NULL;
  if (_program == NULL)
  {
    char* _file_path = (char*) "CL_MM/vglCl3dFuzzyDrasticDilate.cl";
    printf("Compiling %s\n", _file_path);
    std::ifstream _file(_file_path);
    if(_file.fail())
    {
      fprintf(stderr, "%s:%s: Error: File %s not found.\n", __FILE__, __FUNCTION__, _file_path);
      exit(1);
    }
    std::string _prog( std::istreambuf_iterator<char>( _file ), ( std::istreambuf_iterator<char>() ) );
    const char *_source_str = _prog.c_str();
#ifdef __DEBUG__
    printf("Kernel to be compiled:\n%s\n", _source_str);
#endif
    _program = clCreateProgramWithSource(cl.context, 1, (const char **) &_source_str, 0, &_err );
    vglClCheckError(_err, (char*) "clCreateProgramWithSource" );
    _err = clBuildProgram(_program, 1, cl.deviceId, "-I CL_MM/", NULL, NULL );
    vglClBuildDebug(_err, _program);
  }

  static cl_kernel _kernel = NULL;
  if (_kernel == NULL)
  {
    _kernel = clCreateKernel( _program, "vglCl3dFuzzyDrasticDilate", &_err );
    vglClCheckError(_err, (char*) "clCreateKernel" );
  }


  _err = clSetKernelArg( _kernel, 0, sizeof( cl_mem ), (void*) &img_input->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 0" );

  _err = clSetKernelArg( _kernel, 1, sizeof( cl_mem ), (void*) &img_output->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 1" );

  _err = clSetKernelArg( _kernel, 2, sizeof( cl_mem ), (float*) &mobj_convolution_window );
  vglClCheckError( _err, (char*) "clSetKernelArg 2" );

  _err = clSetKernelArg( _kernel, 3, sizeof( int ), &window_size_x );
  vglClCheckError( _err, (char*) "clSetKernelArg 3" );

  _err = clSetKernelArg( _kernel, 4, sizeof( int ), &window_size_y );
  vglClCheckError( _err, (char*) "clSetKernelArg 4" );

  _err = clSetKernelArg( _kernel, 5, sizeof( int ), &window_size_z );
  vglClCheckError( _err, (char*) "clSetKernelArg 5" );

  int _ndim = 2;
  if (img_input->ndim > 2){
    _ndim = 3;
  }

  size_t _worksize_0 = img_input->getWidthIn();
  if (img_input->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_input->getWidthStep();
  }
  if (img_output->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_output->getWidthStep();
  }

  size_t worksize[] = { _worksize_0, img_input->getHeightIn(),  img_input->getNFrames() };
  clEnqueueNDRangeKernel( cl.commandQueue, _kernel, _ndim, NULL, worksize, 0, 0, 0, 0 );

  vglClCheckError( _err, (char*) "clEnqueueNDRangeKernel" );

  _err = clReleaseMemObject( mobj_convolution_window );
  vglClCheckError(_err, (char*) "clReleaseMemObject mobj_convolution_window");

  vglSetContext(img_output, VGL_CL_CONTEXT);
}

/** Erosion of src image by mask. Result is stored in dst image.

  */
void vglCl3dFuzzyDrasticErode(VglImage* img_input, VglImage* img_output, float* convolution_window, int window_size_x, int window_size_y, int window_size_z)
{
  vglCheckContext(img_input, VGL_CL_CONTEXT);
  vglCheckContext(img_output, VGL_CL_CONTEXT);

  cl_int _err;

  cl_mem mobj_convolution_window = NULL;
  mobj_convolution_window = clCreateBuffer(cl.context, CL_MEM_READ_ONLY, (window_size_x*window_size_y*window_size_z)*sizeof(float), NULL, &_err);
  vglClCheckError( _err, (char*) "clCreateBuffer convolution_window" );
  _err = clEnqueueWriteBuffer(cl.commandQueue, mobj_convolution_window, CL_TRUE, 0, (window_size_x*window_size_y*window_size_z)*sizeof(float), convolution_window, 0, NULL, NULL);
  vglClCheckError( _err, (char*) "clEnqueueWriteBuffer convolution_window" );

  static cl_program _program = NULL;
  if (_program == NULL)
  {
    char* _file_path = (char*) "CL_MM/vglCl3dFuzzyDrasticErode.cl";
    printf("Compiling %s\n", _file_path);
    std::ifstream _file(_file_path);
    if(_file.fail())
    {
      fprintf(stderr, "%s:%s: Error: File %s not found.\n", __FILE__, __FUNCTION__, _file_path);
      exit(1);
    }
    std::string _prog( std::istreambuf_iterator<char>( _file ), ( std::istreambuf_iterator<char>() ) );
    const char *_source_str = _prog.c_str();
#ifdef __DEBUG__
    printf("Kernel to be compiled:\n%s\n", _source_str);
#endif
    _program = clCreateProgramWithSource(cl.context, 1, (const char **) &_source_str, 0, &_err );
    vglClCheckError(_err, (char*) "clCreateProgramWithSource" );
    _err = clBuildProgram(_program, 1, cl.deviceId, "-I CL_MM/", NULL, NULL );
    vglClBuildDebug(_err, _program);
  }

  static cl_kernel _kernel = NULL;
  if (_kernel == NULL)
  {
    _kernel = clCreateKernel( _program, "vglCl3dFuzzyDrasticErode", &_err );
    vglClCheckError(_err, (char*) "clCreateKernel" );
  }


  _err = clSetKernelArg( _kernel, 0, sizeof( cl_mem ), (void*) &img_input->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 0" );

  _err = clSetKernelArg( _kernel, 1, sizeof( cl_mem ), (void*) &img_output->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 1" );

  _err = clSetKernelArg( _kernel, 2, sizeof( cl_mem ), (float*) &mobj_convolution_window );
  vglClCheckError( _err, (char*) "clSetKernelArg 2" );

  _err = clSetKernelArg( _kernel, 3, sizeof( int ), &window_size_x );
  vglClCheckError( _err, (char*) "clSetKernelArg 3" );

  _err = clSetKernelArg( _kernel, 4, sizeof( int ), &window_size_y );
  vglClCheckError( _err, (char*) "clSetKernelArg 4" );

  _err = clSetKernelArg( _kernel, 5, sizeof( int ), &window_size_z );
  vglClCheckError( _err, (char*) "clSetKernelArg 5" );

  int _ndim = 2;
  if (img_input->ndim > 2){
    _ndim = 3;
  }

  size_t _worksize_0 = img_input->getWidthIn();
  if (img_input->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_input->getWidthStep();
  }
  if (img_output->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_output->getWidthStep();
  }

  size_t worksize[] = { _worksize_0, img_input->getHeightIn(),  img_input->getNFrames() };
  clEnqueueNDRangeKernel( cl.commandQueue, _kernel, _ndim, NULL, worksize, 0, 0, 0, 0 );

  vglClCheckError( _err, (char*) "clEnqueueNDRangeKernel" );

  _err = clReleaseMemObject( mobj_convolution_window );
  vglClCheckError(_err, (char*) "clReleaseMemObject mobj_convolution_window");

  vglSetContext(img_output, VGL_CL_CONTEXT);
}

/** Erosion of src image by mask. Result is stored in dst image.

  */
void vglCl3dFuzzyGeoDilate(VglImage* img_input, VglImage* img_output, float* convolution_window, int window_size_x, int window_size_y, int window_size_z)
{
  vglCheckContext(img_input, VGL_CL_CONTEXT);
  vglCheckContext(img_output, VGL_CL_CONTEXT);

  cl_int _err;

  cl_mem mobj_convolution_window = NULL;
  mobj_convolution_window = clCreateBuffer(cl.context, CL_MEM_READ_ONLY, (window_size_x*window_size_y*window_size_z)*sizeof(float), NULL, &_err);
  vglClCheckError( _err, (char*) "clCreateBuffer convolution_window" );
  _err = clEnqueueWriteBuffer(cl.commandQueue, mobj_convolution_window, CL_TRUE, 0, (window_size_x*window_size_y*window_size_z)*sizeof(float), convolution_window, 0, NULL, NULL);
  vglClCheckError( _err, (char*) "clEnqueueWriteBuffer convolution_window" );

  static cl_program _program = NULL;
  if (_program == NULL)
  {
    char* _file_path = (char*) "CL_MM/vglCl3dFuzzyGeoDilate.cl";
    printf("Compiling %s\n", _file_path);
    std::ifstream _file(_file_path);
    if(_file.fail())
    {
      fprintf(stderr, "%s:%s: Error: File %s not found.\n", __FILE__, __FUNCTION__, _file_path);
      exit(1);
    }
    std::string _prog( std::istreambuf_iterator<char>( _file ), ( std::istreambuf_iterator<char>() ) );
    const char *_source_str = _prog.c_str();
#ifdef __DEBUG__
    printf("Kernel to be compiled:\n%s\n", _source_str);
#endif
    _program = clCreateProgramWithSource(cl.context, 1, (const char **) &_source_str, 0, &_err );
    vglClCheckError(_err, (char*) "clCreateProgramWithSource" );
    _err = clBuildProgram(_program, 1, cl.deviceId, "-I CL_MM/", NULL, NULL );
    vglClBuildDebug(_err, _program);
  }

  static cl_kernel _kernel = NULL;
  if (_kernel == NULL)
  {
    _kernel = clCreateKernel( _program, "vglCl3dFuzzyGeoDilate", &_err );
    vglClCheckError(_err, (char*) "clCreateKernel" );
  }


  _err = clSetKernelArg( _kernel, 0, sizeof( cl_mem ), (void*) &img_input->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 0" );

  _err = clSetKernelArg( _kernel, 1, sizeof( cl_mem ), (void*) &img_output->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 1" );

  _err = clSetKernelArg( _kernel, 2, sizeof( cl_mem ), (float*) &mobj_convolution_window );
  vglClCheckError( _err, (char*) "clSetKernelArg 2" );

  _err = clSetKernelArg( _kernel, 3, sizeof( int ), &window_size_x );
  vglClCheckError( _err, (char*) "clSetKernelArg 3" );

  _err = clSetKernelArg( _kernel, 4, sizeof( int ), &window_size_y );
  vglClCheckError( _err, (char*) "clSetKernelArg 4" );

  _err = clSetKernelArg( _kernel, 5, sizeof( int ), &window_size_z );
  vglClCheckError( _err, (char*) "clSetKernelArg 5" );

  int _ndim = 2;
  if (img_input->ndim > 2){
    _ndim = 3;
  }

  size_t _worksize_0 = img_input->getWidthIn();
  if (img_input->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_input->getWidthStep();
  }
  if (img_output->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_output->getWidthStep();
  }

  size_t worksize[] = { _worksize_0, img_input->getHeightIn(),  img_input->getNFrames() };
  clEnqueueNDRangeKernel( cl.commandQueue, _kernel, _ndim, NULL, worksize, 0, 0, 0, 0 );

  vglClCheckError( _err, (char*) "clEnqueueNDRangeKernel" );

  _err = clReleaseMemObject( mobj_convolution_window );
  vglClCheckError(_err, (char*) "clReleaseMemObject mobj_convolution_window");

  vglSetContext(img_output, VGL_CL_CONTEXT);
}

/** Erosion of src image by mask. Result is stored in dst image.

  */
void vglCl3dFuzzyGeoErode(VglImage* img_input, VglImage* img_output, float* convolution_window, int window_size_x, int window_size_y, int window_size_z)
{
  vglCheckContext(img_input, VGL_CL_CONTEXT);
  vglCheckContext(img_output, VGL_CL_CONTEXT);

  cl_int _err;

  cl_mem mobj_convolution_window = NULL;
  mobj_convolution_window = clCreateBuffer(cl.context, CL_MEM_READ_ONLY, (window_size_x*window_size_y*window_size_z)*sizeof(float), NULL, &_err);
  vglClCheckError( _err, (char*) "clCreateBuffer convolution_window" );
  _err = clEnqueueWriteBuffer(cl.commandQueue, mobj_convolution_window, CL_TRUE, 0, (window_size_x*window_size_y*window_size_z)*sizeof(float), convolution_window, 0, NULL, NULL);
  vglClCheckError( _err, (char*) "clEnqueueWriteBuffer convolution_window" );

  static cl_program _program = NULL;
  if (_program == NULL)
  {
    char* _file_path = (char*) "CL_MM/vglCl3dFuzzyGeoErode.cl";
    printf("Compiling %s\n", _file_path);
    std::ifstream _file(_file_path);
    if(_file.fail())
    {
      fprintf(stderr, "%s:%s: Error: File %s not found.\n", __FILE__, __FUNCTION__, _file_path);
      exit(1);
    }
    std::string _prog( std::istreambuf_iterator<char>( _file ), ( std::istreambuf_iterator<char>() ) );
    const char *_source_str = _prog.c_str();
#ifdef __DEBUG__
    printf("Kernel to be compiled:\n%s\n", _source_str);
#endif
    _program = clCreateProgramWithSource(cl.context, 1, (const char **) &_source_str, 0, &_err );
    vglClCheckError(_err, (char*) "clCreateProgramWithSource" );
    _err = clBuildProgram(_program, 1, cl.deviceId, "-I CL_MM/", NULL, NULL );
    vglClBuildDebug(_err, _program);
  }

  static cl_kernel _kernel = NULL;
  if (_kernel == NULL)
  {
    _kernel = clCreateKernel( _program, "vglCl3dFuzzyGeoErode", &_err );
    vglClCheckError(_err, (char*) "clCreateKernel" );
  }


  _err = clSetKernelArg( _kernel, 0, sizeof( cl_mem ), (void*) &img_input->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 0" );

  _err = clSetKernelArg( _kernel, 1, sizeof( cl_mem ), (void*) &img_output->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 1" );

  _err = clSetKernelArg( _kernel, 2, sizeof( cl_mem ), (float*) &mobj_convolution_window );
  vglClCheckError( _err, (char*) "clSetKernelArg 2" );

  _err = clSetKernelArg( _kernel, 3, sizeof( int ), &window_size_x );
  vglClCheckError( _err, (char*) "clSetKernelArg 3" );

  _err = clSetKernelArg( _kernel, 4, sizeof( int ), &window_size_y );
  vglClCheckError( _err, (char*) "clSetKernelArg 4" );

  _err = clSetKernelArg( _kernel, 5, sizeof( int ), &window_size_z );
  vglClCheckError( _err, (char*) "clSetKernelArg 5" );

  int _ndim = 2;
  if (img_input->ndim > 2){
    _ndim = 3;
  }

  size_t _worksize_0 = img_input->getWidthIn();
  if (img_input->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_input->getWidthStep();
  }
  if (img_output->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_output->getWidthStep();
  }

  size_t worksize[] = { _worksize_0, img_input->getHeightIn(),  img_input->getNFrames() };
  clEnqueueNDRangeKernel( cl.commandQueue, _kernel, _ndim, NULL, worksize, 0, 0, 0, 0 );

  vglClCheckError( _err, (char*) "clEnqueueNDRangeKernel" );

  _err = clReleaseMemObject( mobj_convolution_window );
  vglClCheckError(_err, (char*) "clReleaseMemObject mobj_convolution_window");

  vglSetContext(img_output, VGL_CL_CONTEXT);
}

/** Erosion of src image by mask. Result is stored in dst image.

  */
void vglCl3dFuzzyHamacherDilate(VglImage* img_input, VglImage* img_output, float* convolution_window, int window_size_x, int window_size_y, int window_size_z, float gama)
{
  vglCheckContext(img_input, VGL_CL_CONTEXT);
  vglCheckContext(img_output, VGL_CL_CONTEXT);

  cl_int _err;

  cl_mem mobj_convolution_window = NULL;
  mobj_convolution_window = clCreateBuffer(cl.context, CL_MEM_READ_ONLY, (window_size_x*window_size_y*window_size_z)*sizeof(float), NULL, &_err);
  vglClCheckError( _err, (char*) "clCreateBuffer convolution_window" );
  _err = clEnqueueWriteBuffer(cl.commandQueue, mobj_convolution_window, CL_TRUE, 0, (window_size_x*window_size_y*window_size_z)*sizeof(float), convolution_window, 0, NULL, NULL);
  vglClCheckError( _err, (char*) "clEnqueueWriteBuffer convolution_window" );

  static cl_program _program = NULL;
  if (_program == NULL)
  {
    char* _file_path = (char*) "CL_MM/vglCl3dFuzzyHamacherDilate.cl";
    printf("Compiling %s\n", _file_path);
    std::ifstream _file(_file_path);
    if(_file.fail())
    {
      fprintf(stderr, "%s:%s: Error: File %s not found.\n", __FILE__, __FUNCTION__, _file_path);
      exit(1);
    }
    std::string _prog( std::istreambuf_iterator<char>( _file ), ( std::istreambuf_iterator<char>() ) );
    const char *_source_str = _prog.c_str();
#ifdef __DEBUG__
    printf("Kernel to be compiled:\n%s\n", _source_str);
#endif
    _program = clCreateProgramWithSource(cl.context, 1, (const char **) &_source_str, 0, &_err );
    vglClCheckError(_err, (char*) "clCreateProgramWithSource" );
    _err = clBuildProgram(_program, 1, cl.deviceId, "-I CL_MM/", NULL, NULL );
    vglClBuildDebug(_err, _program);
  }

  static cl_kernel _kernel = NULL;
  if (_kernel == NULL)
  {
    _kernel = clCreateKernel( _program, "vglCl3dFuzzyHamacherDilate", &_err );
    vglClCheckError(_err, (char*) "clCreateKernel" );
  }


  _err = clSetKernelArg( _kernel, 0, sizeof( cl_mem ), (void*) &img_input->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 0" );

  _err = clSetKernelArg( _kernel, 1, sizeof( cl_mem ), (void*) &img_output->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 1" );

  _err = clSetKernelArg( _kernel, 2, sizeof( cl_mem ), (float*) &mobj_convolution_window );
  vglClCheckError( _err, (char*) "clSetKernelArg 2" );

  _err = clSetKernelArg( _kernel, 3, sizeof( int ), &window_size_x );
  vglClCheckError( _err, (char*) "clSetKernelArg 3" );

  _err = clSetKernelArg( _kernel, 4, sizeof( int ), &window_size_y );
  vglClCheckError( _err, (char*) "clSetKernelArg 4" );

  _err = clSetKernelArg( _kernel, 5, sizeof( int ), &window_size_z );
  vglClCheckError( _err, (char*) "clSetKernelArg 5" );

  _err = clSetKernelArg( _kernel, 6, sizeof( float ), &gama );
  vglClCheckError( _err, (char*) "clSetKernelArg 6" );

  int _ndim = 2;
  if (img_input->ndim > 2){
    _ndim = 3;
  }

  size_t _worksize_0 = img_input->getWidthIn();
  if (img_input->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_input->getWidthStep();
  }
  if (img_output->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_output->getWidthStep();
  }

  size_t worksize[] = { _worksize_0, img_input->getHeightIn(),  img_input->getNFrames() };
  clEnqueueNDRangeKernel( cl.commandQueue, _kernel, _ndim, NULL, worksize, 0, 0, 0, 0 );

  vglClCheckError( _err, (char*) "clEnqueueNDRangeKernel" );

  _err = clReleaseMemObject( mobj_convolution_window );
  vglClCheckError(_err, (char*) "clReleaseMemObject mobj_convolution_window");

  vglSetContext(img_output, VGL_CL_CONTEXT);
}

/** Erosion of src image by mask. Result is stored in dst image.

  */
void vglCl3dFuzzyHamacherErode(VglImage* img_input, VglImage* img_output, float* convolution_window, int window_size_x, int window_size_y, int window_size_z, float gama)
{
  vglCheckContext(img_input, VGL_CL_CONTEXT);
  vglCheckContext(img_output, VGL_CL_CONTEXT);

  cl_int _err;

  cl_mem mobj_convolution_window = NULL;
  mobj_convolution_window = clCreateBuffer(cl.context, CL_MEM_READ_ONLY, (window_size_x*window_size_y*window_size_z)*sizeof(float), NULL, &_err);
  vglClCheckError( _err, (char*) "clCreateBuffer convolution_window" );
  _err = clEnqueueWriteBuffer(cl.commandQueue, mobj_convolution_window, CL_TRUE, 0, (window_size_x*window_size_y*window_size_z)*sizeof(float), convolution_window, 0, NULL, NULL);
  vglClCheckError( _err, (char*) "clEnqueueWriteBuffer convolution_window" );

  static cl_program _program = NULL;
  if (_program == NULL)
  {
    char* _file_path = (char*) "CL_MM/vglCl3dFuzzyHamacherErode.cl";
    printf("Compiling %s\n", _file_path);
    std::ifstream _file(_file_path);
    if(_file.fail())
    {
      fprintf(stderr, "%s:%s: Error: File %s not found.\n", __FILE__, __FUNCTION__, _file_path);
      exit(1);
    }
    std::string _prog( std::istreambuf_iterator<char>( _file ), ( std::istreambuf_iterator<char>() ) );
    const char *_source_str = _prog.c_str();
#ifdef __DEBUG__
    printf("Kernel to be compiled:\n%s\n", _source_str);
#endif
    _program = clCreateProgramWithSource(cl.context, 1, (const char **) &_source_str, 0, &_err );
    vglClCheckError(_err, (char*) "clCreateProgramWithSource" );
    _err = clBuildProgram(_program, 1, cl.deviceId, "-I CL_MM/", NULL, NULL );
    vglClBuildDebug(_err, _program);
  }

  static cl_kernel _kernel = NULL;
  if (_kernel == NULL)
  {
    _kernel = clCreateKernel( _program, "vglCl3dFuzzyHamacherErode", &_err );
    vglClCheckError(_err, (char*) "clCreateKernel" );
  }


  _err = clSetKernelArg( _kernel, 0, sizeof( cl_mem ), (void*) &img_input->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 0" );

  _err = clSetKernelArg( _kernel, 1, sizeof( cl_mem ), (void*) &img_output->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 1" );

  _err = clSetKernelArg( _kernel, 2, sizeof( cl_mem ), (float*) &mobj_convolution_window );
  vglClCheckError( _err, (char*) "clSetKernelArg 2" );

  _err = clSetKernelArg( _kernel, 3, sizeof( int ), &window_size_x );
  vglClCheckError( _err, (char*) "clSetKernelArg 3" );

  _err = clSetKernelArg( _kernel, 4, sizeof( int ), &window_size_y );
  vglClCheckError( _err, (char*) "clSetKernelArg 4" );

  _err = clSetKernelArg( _kernel, 5, sizeof( int ), &window_size_z );
  vglClCheckError( _err, (char*) "clSetKernelArg 5" );

  _err = clSetKernelArg( _kernel, 6, sizeof( float ), &gama );
  vglClCheckError( _err, (char*) "clSetKernelArg 6" );

  int _ndim = 2;
  if (img_input->ndim > 2){
    _ndim = 3;
  }

  size_t _worksize_0 = img_input->getWidthIn();
  if (img_input->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_input->getWidthStep();
  }
  if (img_output->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_output->getWidthStep();
  }

  size_t worksize[] = { _worksize_0, img_input->getHeightIn(),  img_input->getNFrames() };
  clEnqueueNDRangeKernel( cl.commandQueue, _kernel, _ndim, NULL, worksize, 0, 0, 0, 0 );

  vglClCheckError( _err, (char*) "clEnqueueNDRangeKernel" );

  _err = clReleaseMemObject( mobj_convolution_window );
  vglClCheckError(_err, (char*) "clReleaseMemObject mobj_convolution_window");

  vglSetContext(img_output, VGL_CL_CONTEXT);
}

/** Erosion of src image by mask. Result is stored in dst image.

  */
void vglCl3dFuzzyStdDilate(VglImage* img_input, VglImage* img_output, float* convolution_window, int window_size_x, int window_size_y, int window_size_z)
{
  vglCheckContext(img_input, VGL_CL_CONTEXT);
  vglCheckContext(img_output, VGL_CL_CONTEXT);

  cl_int _err;

  cl_mem mobj_convolution_window = NULL;
  mobj_convolution_window = clCreateBuffer(cl.context, CL_MEM_READ_ONLY, (window_size_x*window_size_y*window_size_z)*sizeof(float), NULL, &_err);
  vglClCheckError( _err, (char*) "clCreateBuffer convolution_window" );
  _err = clEnqueueWriteBuffer(cl.commandQueue, mobj_convolution_window, CL_TRUE, 0, (window_size_x*window_size_y*window_size_z)*sizeof(float), convolution_window, 0, NULL, NULL);
  vglClCheckError( _err, (char*) "clEnqueueWriteBuffer convolution_window" );

  static cl_program _program = NULL;
  if (_program == NULL)
  {
    char* _file_path = (char*) "CL_MM/vglCl3dFuzzyStdDilate.cl";
    printf("Compiling %s\n", _file_path);
    std::ifstream _file(_file_path);
    if(_file.fail())
    {
      fprintf(stderr, "%s:%s: Error: File %s not found.\n", __FILE__, __FUNCTION__, _file_path);
      exit(1);
    }
    std::string _prog( std::istreambuf_iterator<char>( _file ), ( std::istreambuf_iterator<char>() ) );
    const char *_source_str = _prog.c_str();
#ifdef __DEBUG__
    printf("Kernel to be compiled:\n%s\n", _source_str);
#endif
    _program = clCreateProgramWithSource(cl.context, 1, (const char **) &_source_str, 0, &_err );
    vglClCheckError(_err, (char*) "clCreateProgramWithSource" );
    _err = clBuildProgram(_program, 1, cl.deviceId, "-I CL_MM/", NULL, NULL );
    vglClBuildDebug(_err, _program);
  }

  static cl_kernel _kernel = NULL;
  if (_kernel == NULL)
  {
    _kernel = clCreateKernel( _program, "vglCl3dFuzzyStdDilate", &_err );
    vglClCheckError(_err, (char*) "clCreateKernel" );
  }


  _err = clSetKernelArg( _kernel, 0, sizeof( cl_mem ), (void*) &img_input->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 0" );

  _err = clSetKernelArg( _kernel, 1, sizeof( cl_mem ), (void*) &img_output->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 1" );

  _err = clSetKernelArg( _kernel, 2, sizeof( cl_mem ), (float*) &mobj_convolution_window );
  vglClCheckError( _err, (char*) "clSetKernelArg 2" );

  _err = clSetKernelArg( _kernel, 3, sizeof( int ), &window_size_x );
  vglClCheckError( _err, (char*) "clSetKernelArg 3" );

  _err = clSetKernelArg( _kernel, 4, sizeof( int ), &window_size_y );
  vglClCheckError( _err, (char*) "clSetKernelArg 4" );

  _err = clSetKernelArg( _kernel, 5, sizeof( int ), &window_size_z );
  vglClCheckError( _err, (char*) "clSetKernelArg 5" );

  int _ndim = 2;
  if (img_input->ndim > 2){
    _ndim = 3;
  }

  size_t _worksize_0 = img_input->getWidthIn();
  if (img_input->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_input->getWidthStep();
  }
  if (img_output->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_output->getWidthStep();
  }

  size_t worksize[] = { _worksize_0, img_input->getHeightIn(),  img_input->getNFrames() };
  clEnqueueNDRangeKernel( cl.commandQueue, _kernel, _ndim, NULL, worksize, 0, 0, 0, 0 );

  vglClCheckError( _err, (char*) "clEnqueueNDRangeKernel" );

  _err = clReleaseMemObject( mobj_convolution_window );
  vglClCheckError(_err, (char*) "clReleaseMemObject mobj_convolution_window");

  vglSetContext(img_output, VGL_CL_CONTEXT);
}

/** Erosion of src image by mask. Result is stored in dst image.

  */
void vglCl3dFuzzyStdErode(VglImage* img_input, VglImage* img_output, float* convolution_window, int window_size_x, int window_size_y, int window_size_z)
{
  vglCheckContext(img_input, VGL_CL_CONTEXT);
  vglCheckContext(img_output, VGL_CL_CONTEXT);

  cl_int _err;

  cl_mem mobj_convolution_window = NULL;
  mobj_convolution_window = clCreateBuffer(cl.context, CL_MEM_READ_ONLY, (window_size_x*window_size_y*window_size_z)*sizeof(float), NULL, &_err);
  vglClCheckError( _err, (char*) "clCreateBuffer convolution_window" );
  _err = clEnqueueWriteBuffer(cl.commandQueue, mobj_convolution_window, CL_TRUE, 0, (window_size_x*window_size_y*window_size_z)*sizeof(float), convolution_window, 0, NULL, NULL);
  vglClCheckError( _err, (char*) "clEnqueueWriteBuffer convolution_window" );

  static cl_program _program = NULL;
  if (_program == NULL)
  {
    char* _file_path = (char*) "CL_MM/vglCl3dFuzzyStdErode.cl";
    printf("Compiling %s\n", _file_path);
    std::ifstream _file(_file_path);
    if(_file.fail())
    {
      fprintf(stderr, "%s:%s: Error: File %s not found.\n", __FILE__, __FUNCTION__, _file_path);
      exit(1);
    }
    std::string _prog( std::istreambuf_iterator<char>( _file ), ( std::istreambuf_iterator<char>() ) );
    const char *_source_str = _prog.c_str();
#ifdef __DEBUG__
    printf("Kernel to be compiled:\n%s\n", _source_str);
#endif
    _program = clCreateProgramWithSource(cl.context, 1, (const char **) &_source_str, 0, &_err );
    vglClCheckError(_err, (char*) "clCreateProgramWithSource" );
    _err = clBuildProgram(_program, 1, cl.deviceId, "-I CL_MM/", NULL, NULL );
    vglClBuildDebug(_err, _program);
  }

  static cl_kernel _kernel = NULL;
  if (_kernel == NULL)
  {
    _kernel = clCreateKernel( _program, "vglCl3dFuzzyStdErode", &_err );
    vglClCheckError(_err, (char*) "clCreateKernel" );
  }


  _err = clSetKernelArg( _kernel, 0, sizeof( cl_mem ), (void*) &img_input->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 0" );

  _err = clSetKernelArg( _kernel, 1, sizeof( cl_mem ), (void*) &img_output->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 1" );

  _err = clSetKernelArg( _kernel, 2, sizeof( cl_mem ), (float*) &mobj_convolution_window );
  vglClCheckError( _err, (char*) "clSetKernelArg 2" );

  _err = clSetKernelArg( _kernel, 3, sizeof( int ), &window_size_x );
  vglClCheckError( _err, (char*) "clSetKernelArg 3" );

  _err = clSetKernelArg( _kernel, 4, sizeof( int ), &window_size_y );
  vglClCheckError( _err, (char*) "clSetKernelArg 4" );

  _err = clSetKernelArg( _kernel, 5, sizeof( int ), &window_size_z );
  vglClCheckError( _err, (char*) "clSetKernelArg 5" );

  int _ndim = 2;
  if (img_input->ndim > 2){
    _ndim = 3;
  }

  size_t _worksize_0 = img_input->getWidthIn();
  if (img_input->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_input->getWidthStep();
  }
  if (img_output->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_output->getWidthStep();
  }

  size_t worksize[] = { _worksize_0, img_input->getHeightIn(),  img_input->getNFrames() };
  clEnqueueNDRangeKernel( cl.commandQueue, _kernel, _ndim, NULL, worksize, 0, 0, 0, 0 );

  vglClCheckError( _err, (char*) "clEnqueueNDRangeKernel" );

  _err = clReleaseMemObject( mobj_convolution_window );
  vglClCheckError(_err, (char*) "clReleaseMemObject mobj_convolution_window");

  vglSetContext(img_output, VGL_CL_CONTEXT);
}

/** Erosion of src image by mask. Result is stored in dst image.

  */
void vglClFuzzyAlgDilate(VglImage* img_input, VglImage* img_output, float* convolution_window, int window_size_x, int window_size_y)
{
  vglCheckContext(img_input, VGL_CL_CONTEXT);
  vglCheckContext(img_output, VGL_CL_CONTEXT);

  cl_int _err;

  cl_mem mobj_convolution_window = NULL;
  mobj_convolution_window = clCreateBuffer(cl.context, CL_MEM_READ_ONLY, (window_size_x*window_size_y)*sizeof(float), NULL, &_err);
  vglClCheckError( _err, (char*) "clCreateBuffer convolution_window" );
  _err = clEnqueueWriteBuffer(cl.commandQueue, mobj_convolution_window, CL_TRUE, 0, (window_size_x*window_size_y)*sizeof(float), convolution_window, 0, NULL, NULL);
  vglClCheckError( _err, (char*) "clEnqueueWriteBuffer convolution_window" );

  static cl_program _program = NULL;
  if (_program == NULL)
  {
    char* _file_path = (char*) "CL_MM/vglClFuzzyAlgDilate.cl";
    printf("Compiling %s\n", _file_path);
    std::ifstream _file(_file_path);
    if(_file.fail())
    {
      fprintf(stderr, "%s:%s: Error: File %s not found.\n", __FILE__, __FUNCTION__, _file_path);
      exit(1);
    }
    std::string _prog( std::istreambuf_iterator<char>( _file ), ( std::istreambuf_iterator<char>() ) );
    const char *_source_str = _prog.c_str();
#ifdef __DEBUG__
    printf("Kernel to be compiled:\n%s\n", _source_str);
#endif
    _program = clCreateProgramWithSource(cl.context, 1, (const char **) &_source_str, 0, &_err );
    vglClCheckError(_err, (char*) "clCreateProgramWithSource" );
    _err = clBuildProgram(_program, 1, cl.deviceId, "-I CL_MM/", NULL, NULL );
    vglClBuildDebug(_err, _program);
  }

  static cl_kernel _kernel = NULL;
  if (_kernel == NULL)
  {
    _kernel = clCreateKernel( _program, "vglClFuzzyAlgDilate", &_err );
    vglClCheckError(_err, (char*) "clCreateKernel" );
  }


  _err = clSetKernelArg( _kernel, 0, sizeof( cl_mem ), (void*) &img_input->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 0" );

  _err = clSetKernelArg( _kernel, 1, sizeof( cl_mem ), (void*) &img_output->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 1" );

  _err = clSetKernelArg( _kernel, 2, sizeof( cl_mem ), (float*) &mobj_convolution_window );
  vglClCheckError( _err, (char*) "clSetKernelArg 2" );

  _err = clSetKernelArg( _kernel, 3, sizeof( int ), &window_size_x );
  vglClCheckError( _err, (char*) "clSetKernelArg 3" );

  _err = clSetKernelArg( _kernel, 4, sizeof( int ), &window_size_y );
  vglClCheckError( _err, (char*) "clSetKernelArg 4" );

  int _ndim = 2;
  if (img_input->ndim > 2){
    _ndim = 3;
  }

  size_t _worksize_0 = img_input->getWidthIn();
  if (img_input->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_input->getWidthStep();
  }
  if (img_output->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_output->getWidthStep();
  }

  size_t worksize[] = { _worksize_0, img_input->getHeightIn(),  img_input->getNFrames() };
  clEnqueueNDRangeKernel( cl.commandQueue, _kernel, _ndim, NULL, worksize, 0, 0, 0, 0 );

  vglClCheckError( _err, (char*) "clEnqueueNDRangeKernel" );

  _err = clReleaseMemObject( mobj_convolution_window );
  vglClCheckError(_err, (char*) "clReleaseMemObject mobj_convolution_window");

  vglSetContext(img_output, VGL_CL_CONTEXT);
}

/** Erosion of src image by mask. Result is stored in dst image.

  */
void vglClFuzzyAlgErode(VglImage* img_input, VglImage* img_output, float* convolution_window, int window_size_x, int window_size_y)
{
  vglCheckContext(img_input, VGL_CL_CONTEXT);
  vglCheckContext(img_output, VGL_CL_CONTEXT);

  cl_int _err;

  cl_mem mobj_convolution_window = NULL;
  mobj_convolution_window = clCreateBuffer(cl.context, CL_MEM_READ_ONLY, (window_size_x*window_size_y)*sizeof(float), NULL, &_err);
  vglClCheckError( _err, (char*) "clCreateBuffer convolution_window" );
  _err = clEnqueueWriteBuffer(cl.commandQueue, mobj_convolution_window, CL_TRUE, 0, (window_size_x*window_size_y)*sizeof(float), convolution_window, 0, NULL, NULL);
  vglClCheckError( _err, (char*) "clEnqueueWriteBuffer convolution_window" );

  static cl_program _program = NULL;
  if (_program == NULL)
  {
    char* _file_path = (char*) "CL_MM/vglClFuzzyAlgErode.cl";
    printf("Compiling %s\n", _file_path);
    std::ifstream _file(_file_path);
    if(_file.fail())
    {
      fprintf(stderr, "%s:%s: Error: File %s not found.\n", __FILE__, __FUNCTION__, _file_path);
      exit(1);
    }
    std::string _prog( std::istreambuf_iterator<char>( _file ), ( std::istreambuf_iterator<char>() ) );
    const char *_source_str = _prog.c_str();
#ifdef __DEBUG__
    printf("Kernel to be compiled:\n%s\n", _source_str);
#endif
    _program = clCreateProgramWithSource(cl.context, 1, (const char **) &_source_str, 0, &_err );
    vglClCheckError(_err, (char*) "clCreateProgramWithSource" );
    _err = clBuildProgram(_program, 1, cl.deviceId, "-I CL_MM/", NULL, NULL );
    vglClBuildDebug(_err, _program);
  }

  static cl_kernel _kernel = NULL;
  if (_kernel == NULL)
  {
    _kernel = clCreateKernel( _program, "vglClFuzzyAlgErode", &_err );
    vglClCheckError(_err, (char*) "clCreateKernel" );
  }


  _err = clSetKernelArg( _kernel, 0, sizeof( cl_mem ), (void*) &img_input->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 0" );

  _err = clSetKernelArg( _kernel, 1, sizeof( cl_mem ), (void*) &img_output->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 1" );

  _err = clSetKernelArg( _kernel, 2, sizeof( cl_mem ), (float*) &mobj_convolution_window );
  vglClCheckError( _err, (char*) "clSetKernelArg 2" );

  _err = clSetKernelArg( _kernel, 3, sizeof( int ), &window_size_x );
  vglClCheckError( _err, (char*) "clSetKernelArg 3" );

  _err = clSetKernelArg( _kernel, 4, sizeof( int ), &window_size_y );
  vglClCheckError( _err, (char*) "clSetKernelArg 4" );

  int _ndim = 2;
  if (img_input->ndim > 2){
    _ndim = 3;
  }

  size_t _worksize_0 = img_input->getWidthIn();
  if (img_input->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_input->getWidthStep();
  }
  if (img_output->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_output->getWidthStep();
  }

  size_t worksize[] = { _worksize_0, img_input->getHeightIn(),  img_input->getNFrames() };
  clEnqueueNDRangeKernel( cl.commandQueue, _kernel, _ndim, NULL, worksize, 0, 0, 0, 0 );

  vglClCheckError( _err, (char*) "clEnqueueNDRangeKernel" );

  _err = clReleaseMemObject( mobj_convolution_window );
  vglClCheckError(_err, (char*) "clReleaseMemObject mobj_convolution_window");

  vglSetContext(img_output, VGL_CL_CONTEXT);
}

/** Erosion of src image by mask. Result is stored in dst image.

  */
void vglClFuzzyArithDilate(VglImage* img_input, VglImage* img_output, float* convolution_window, int window_size_x, int window_size_y)
{
  vglCheckContext(img_input, VGL_CL_CONTEXT);
  vglCheckContext(img_output, VGL_CL_CONTEXT);

  cl_int _err;

  cl_mem mobj_convolution_window = NULL;
  mobj_convolution_window = clCreateBuffer(cl.context, CL_MEM_READ_ONLY, (window_size_x*window_size_y)*sizeof(float), NULL, &_err);
  vglClCheckError( _err, (char*) "clCreateBuffer convolution_window" );
  _err = clEnqueueWriteBuffer(cl.commandQueue, mobj_convolution_window, CL_TRUE, 0, (window_size_x*window_size_y)*sizeof(float), convolution_window, 0, NULL, NULL);
  vglClCheckError( _err, (char*) "clEnqueueWriteBuffer convolution_window" );

  static cl_program _program = NULL;
  if (_program == NULL)
  {
    char* _file_path = (char*) "CL_MM/vglClFuzzyArithDilate.cl";
    printf("Compiling %s\n", _file_path);
    std::ifstream _file(_file_path);
    if(_file.fail())
    {
      fprintf(stderr, "%s:%s: Error: File %s not found.\n", __FILE__, __FUNCTION__, _file_path);
      exit(1);
    }
    std::string _prog( std::istreambuf_iterator<char>( _file ), ( std::istreambuf_iterator<char>() ) );
    const char *_source_str = _prog.c_str();
#ifdef __DEBUG__
    printf("Kernel to be compiled:\n%s\n", _source_str);
#endif
    _program = clCreateProgramWithSource(cl.context, 1, (const char **) &_source_str, 0, &_err );
    vglClCheckError(_err, (char*) "clCreateProgramWithSource" );
    _err = clBuildProgram(_program, 1, cl.deviceId, "-I CL_MM/", NULL, NULL );
    vglClBuildDebug(_err, _program);
  }

  static cl_kernel _kernel = NULL;
  if (_kernel == NULL)
  {
    _kernel = clCreateKernel( _program, "vglClFuzzyArithDilate", &_err );
    vglClCheckError(_err, (char*) "clCreateKernel" );
  }


  _err = clSetKernelArg( _kernel, 0, sizeof( cl_mem ), (void*) &img_input->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 0" );

  _err = clSetKernelArg( _kernel, 1, sizeof( cl_mem ), (void*) &img_output->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 1" );

  _err = clSetKernelArg( _kernel, 2, sizeof( cl_mem ), (float*) &mobj_convolution_window );
  vglClCheckError( _err, (char*) "clSetKernelArg 2" );

  _err = clSetKernelArg( _kernel, 3, sizeof( int ), &window_size_x );
  vglClCheckError( _err, (char*) "clSetKernelArg 3" );

  _err = clSetKernelArg( _kernel, 4, sizeof( int ), &window_size_y );
  vglClCheckError( _err, (char*) "clSetKernelArg 4" );

  int _ndim = 2;
  if (img_input->ndim > 2){
    _ndim = 3;
  }

  size_t _worksize_0 = img_input->getWidthIn();
  if (img_input->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_input->getWidthStep();
  }
  if (img_output->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_output->getWidthStep();
  }

  size_t worksize[] = { _worksize_0, img_input->getHeightIn(),  img_input->getNFrames() };
  clEnqueueNDRangeKernel( cl.commandQueue, _kernel, _ndim, NULL, worksize, 0, 0, 0, 0 );

  vglClCheckError( _err, (char*) "clEnqueueNDRangeKernel" );

  _err = clReleaseMemObject( mobj_convolution_window );
  vglClCheckError(_err, (char*) "clReleaseMemObject mobj_convolution_window");

  vglSetContext(img_output, VGL_CL_CONTEXT);
}

/** Erosion of src image by mask. Result is stored in dst image.

  */
void vglClFuzzyArithErode(VglImage* img_input, VglImage* img_output, float* convolution_window, int window_size_x, int window_size_y)
{
  vglCheckContext(img_input, VGL_CL_CONTEXT);
  vglCheckContext(img_output, VGL_CL_CONTEXT);

  cl_int _err;

  cl_mem mobj_convolution_window = NULL;
  mobj_convolution_window = clCreateBuffer(cl.context, CL_MEM_READ_ONLY, (window_size_x*window_size_y)*sizeof(float), NULL, &_err);
  vglClCheckError( _err, (char*) "clCreateBuffer convolution_window" );
  _err = clEnqueueWriteBuffer(cl.commandQueue, mobj_convolution_window, CL_TRUE, 0, (window_size_x*window_size_y)*sizeof(float), convolution_window, 0, NULL, NULL);
  vglClCheckError( _err, (char*) "clEnqueueWriteBuffer convolution_window" );

  static cl_program _program = NULL;
  if (_program == NULL)
  {
    char* _file_path = (char*) "CL_MM/vglClFuzzyArithErode.cl";
    printf("Compiling %s\n", _file_path);
    std::ifstream _file(_file_path);
    if(_file.fail())
    {
      fprintf(stderr, "%s:%s: Error: File %s not found.\n", __FILE__, __FUNCTION__, _file_path);
      exit(1);
    }
    std::string _prog( std::istreambuf_iterator<char>( _file ), ( std::istreambuf_iterator<char>() ) );
    const char *_source_str = _prog.c_str();
#ifdef __DEBUG__
    printf("Kernel to be compiled:\n%s\n", _source_str);
#endif
    _program = clCreateProgramWithSource(cl.context, 1, (const char **) &_source_str, 0, &_err );
    vglClCheckError(_err, (char*) "clCreateProgramWithSource" );
    _err = clBuildProgram(_program, 1, cl.deviceId, "-I CL_MM/", NULL, NULL );
    vglClBuildDebug(_err, _program);
  }

  static cl_kernel _kernel = NULL;
  if (_kernel == NULL)
  {
    _kernel = clCreateKernel( _program, "vglClFuzzyArithErode", &_err );
    vglClCheckError(_err, (char*) "clCreateKernel" );
  }


  _err = clSetKernelArg( _kernel, 0, sizeof( cl_mem ), (void*) &img_input->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 0" );

  _err = clSetKernelArg( _kernel, 1, sizeof( cl_mem ), (void*) &img_output->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 1" );

  _err = clSetKernelArg( _kernel, 2, sizeof( cl_mem ), (float*) &mobj_convolution_window );
  vglClCheckError( _err, (char*) "clSetKernelArg 2" );

  _err = clSetKernelArg( _kernel, 3, sizeof( int ), &window_size_x );
  vglClCheckError( _err, (char*) "clSetKernelArg 3" );

  _err = clSetKernelArg( _kernel, 4, sizeof( int ), &window_size_y );
  vglClCheckError( _err, (char*) "clSetKernelArg 4" );

  int _ndim = 2;
  if (img_input->ndim > 2){
    _ndim = 3;
  }

  size_t _worksize_0 = img_input->getWidthIn();
  if (img_input->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_input->getWidthStep();
  }
  if (img_output->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_output->getWidthStep();
  }

  size_t worksize[] = { _worksize_0, img_input->getHeightIn(),  img_input->getNFrames() };
  clEnqueueNDRangeKernel( cl.commandQueue, _kernel, _ndim, NULL, worksize, 0, 0, 0, 0 );

  vglClCheckError( _err, (char*) "clEnqueueNDRangeKernel" );

  _err = clReleaseMemObject( mobj_convolution_window );
  vglClCheckError(_err, (char*) "clReleaseMemObject mobj_convolution_window");

  vglSetContext(img_output, VGL_CL_CONTEXT);
}

/** Erosion of src image by mask. Result is stored in dst image.

  */
void vglClFuzzyBoundDilate(VglImage* img_input, VglImage* img_output, float* convolution_window, int window_size_x, int window_size_y)
{
  vglCheckContext(img_input, VGL_CL_CONTEXT);
  vglCheckContext(img_output, VGL_CL_CONTEXT);

  cl_int _err;

  cl_mem mobj_convolution_window = NULL;
  mobj_convolution_window = clCreateBuffer(cl.context, CL_MEM_READ_ONLY, (window_size_x*window_size_y)*sizeof(float), NULL, &_err);
  vglClCheckError( _err, (char*) "clCreateBuffer convolution_window" );
  _err = clEnqueueWriteBuffer(cl.commandQueue, mobj_convolution_window, CL_TRUE, 0, (window_size_x*window_size_y)*sizeof(float), convolution_window, 0, NULL, NULL);
  vglClCheckError( _err, (char*) "clEnqueueWriteBuffer convolution_window" );

  static cl_program _program = NULL;
  if (_program == NULL)
  {
    char* _file_path = (char*) "CL_MM/vglClFuzzyBoundDilate.cl";
    printf("Compiling %s\n", _file_path);
    std::ifstream _file(_file_path);
    if(_file.fail())
    {
      fprintf(stderr, "%s:%s: Error: File %s not found.\n", __FILE__, __FUNCTION__, _file_path);
      exit(1);
    }
    std::string _prog( std::istreambuf_iterator<char>( _file ), ( std::istreambuf_iterator<char>() ) );
    const char *_source_str = _prog.c_str();
#ifdef __DEBUG__
    printf("Kernel to be compiled:\n%s\n", _source_str);
#endif
    _program = clCreateProgramWithSource(cl.context, 1, (const char **) &_source_str, 0, &_err );
    vglClCheckError(_err, (char*) "clCreateProgramWithSource" );
    _err = clBuildProgram(_program, 1, cl.deviceId, "-I CL_MM/", NULL, NULL );
    vglClBuildDebug(_err, _program);
  }

  static cl_kernel _kernel = NULL;
  if (_kernel == NULL)
  {
    _kernel = clCreateKernel( _program, "vglClFuzzyBoundDilate", &_err );
    vglClCheckError(_err, (char*) "clCreateKernel" );
  }


  _err = clSetKernelArg( _kernel, 0, sizeof( cl_mem ), (void*) &img_input->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 0" );

  _err = clSetKernelArg( _kernel, 1, sizeof( cl_mem ), (void*) &img_output->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 1" );

  _err = clSetKernelArg( _kernel, 2, sizeof( cl_mem ), (float*) &mobj_convolution_window );
  vglClCheckError( _err, (char*) "clSetKernelArg 2" );

  _err = clSetKernelArg( _kernel, 3, sizeof( int ), &window_size_x );
  vglClCheckError( _err, (char*) "clSetKernelArg 3" );

  _err = clSetKernelArg( _kernel, 4, sizeof( int ), &window_size_y );
  vglClCheckError( _err, (char*) "clSetKernelArg 4" );

  int _ndim = 2;
  if (img_input->ndim > 2){
    _ndim = 3;
  }

  size_t _worksize_0 = img_input->getWidthIn();
  if (img_input->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_input->getWidthStep();
  }
  if (img_output->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_output->getWidthStep();
  }

  size_t worksize[] = { _worksize_0, img_input->getHeightIn(),  img_input->getNFrames() };
  clEnqueueNDRangeKernel( cl.commandQueue, _kernel, _ndim, NULL, worksize, 0, 0, 0, 0 );

  vglClCheckError( _err, (char*) "clEnqueueNDRangeKernel" );

  _err = clReleaseMemObject( mobj_convolution_window );
  vglClCheckError(_err, (char*) "clReleaseMemObject mobj_convolution_window");

  vglSetContext(img_output, VGL_CL_CONTEXT);
}

/** Erosion of src image by mask. Result is stored in dst image.

  */
void vglClFuzzyBoundErode(VglImage* img_input, VglImage* img_output, float* convolution_window, int window_size_x, int window_size_y)
{
  vglCheckContext(img_input, VGL_CL_CONTEXT);
  vglCheckContext(img_output, VGL_CL_CONTEXT);

  cl_int _err;

  cl_mem mobj_convolution_window = NULL;
  mobj_convolution_window = clCreateBuffer(cl.context, CL_MEM_READ_ONLY, (window_size_x*window_size_y)*sizeof(float), NULL, &_err);
  vglClCheckError( _err, (char*) "clCreateBuffer convolution_window" );
  _err = clEnqueueWriteBuffer(cl.commandQueue, mobj_convolution_window, CL_TRUE, 0, (window_size_x*window_size_y)*sizeof(float), convolution_window, 0, NULL, NULL);
  vglClCheckError( _err, (char*) "clEnqueueWriteBuffer convolution_window" );

  static cl_program _program = NULL;
  if (_program == NULL)
  {
    char* _file_path = (char*) "CL_MM/vglClFuzzyBoundErode.cl";
    printf("Compiling %s\n", _file_path);
    std::ifstream _file(_file_path);
    if(_file.fail())
    {
      fprintf(stderr, "%s:%s: Error: File %s not found.\n", __FILE__, __FUNCTION__, _file_path);
      exit(1);
    }
    std::string _prog( std::istreambuf_iterator<char>( _file ), ( std::istreambuf_iterator<char>() ) );
    const char *_source_str = _prog.c_str();
#ifdef __DEBUG__
    printf("Kernel to be compiled:\n%s\n", _source_str);
#endif
    _program = clCreateProgramWithSource(cl.context, 1, (const char **) &_source_str, 0, &_err );
    vglClCheckError(_err, (char*) "clCreateProgramWithSource" );
    _err = clBuildProgram(_program, 1, cl.deviceId, "-I CL_MM/", NULL, NULL );
    vglClBuildDebug(_err, _program);
  }

  static cl_kernel _kernel = NULL;
  if (_kernel == NULL)
  {
    _kernel = clCreateKernel( _program, "vglClFuzzyBoundErode", &_err );
    vglClCheckError(_err, (char*) "clCreateKernel" );
  }


  _err = clSetKernelArg( _kernel, 0, sizeof( cl_mem ), (void*) &img_input->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 0" );

  _err = clSetKernelArg( _kernel, 1, sizeof( cl_mem ), (void*) &img_output->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 1" );

  _err = clSetKernelArg( _kernel, 2, sizeof( cl_mem ), (float*) &mobj_convolution_window );
  vglClCheckError( _err, (char*) "clSetKernelArg 2" );

  _err = clSetKernelArg( _kernel, 3, sizeof( int ), &window_size_x );
  vglClCheckError( _err, (char*) "clSetKernelArg 3" );

  _err = clSetKernelArg( _kernel, 4, sizeof( int ), &window_size_y );
  vglClCheckError( _err, (char*) "clSetKernelArg 4" );

  int _ndim = 2;
  if (img_input->ndim > 2){
    _ndim = 3;
  }

  size_t _worksize_0 = img_input->getWidthIn();
  if (img_input->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_input->getWidthStep();
  }
  if (img_output->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_output->getWidthStep();
  }

  size_t worksize[] = { _worksize_0, img_input->getHeightIn(),  img_input->getNFrames() };
  clEnqueueNDRangeKernel( cl.commandQueue, _kernel, _ndim, NULL, worksize, 0, 0, 0, 0 );

  vglClCheckError( _err, (char*) "clEnqueueNDRangeKernel" );

  _err = clReleaseMemObject( mobj_convolution_window );
  vglClCheckError(_err, (char*) "clReleaseMemObject mobj_convolution_window");

  vglSetContext(img_output, VGL_CL_CONTEXT);
}

/** Erosion of src image by mask. Result is stored in dst image.

  */
void vglClFuzzyDaPDilate(VglImage* img_input, VglImage* img_output, float* convolution_window, int window_size_x, int window_size_y, float gama)
{
  vglCheckContext(img_input, VGL_CL_CONTEXT);
  vglCheckContext(img_output, VGL_CL_CONTEXT);

  cl_int _err;

  cl_mem mobj_convolution_window = NULL;
  mobj_convolution_window = clCreateBuffer(cl.context, CL_MEM_READ_ONLY, (window_size_x*window_size_y)*sizeof(float), NULL, &_err);
  vglClCheckError( _err, (char*) "clCreateBuffer convolution_window" );
  _err = clEnqueueWriteBuffer(cl.commandQueue, mobj_convolution_window, CL_TRUE, 0, (window_size_x*window_size_y)*sizeof(float), convolution_window, 0, NULL, NULL);
  vglClCheckError( _err, (char*) "clEnqueueWriteBuffer convolution_window" );

  static cl_program _program = NULL;
  if (_program == NULL)
  {
    char* _file_path = (char*) "CL_MM/vglClFuzzyDaPDilate.cl";
    printf("Compiling %s\n", _file_path);
    std::ifstream _file(_file_path);
    if(_file.fail())
    {
      fprintf(stderr, "%s:%s: Error: File %s not found.\n", __FILE__, __FUNCTION__, _file_path);
      exit(1);
    }
    std::string _prog( std::istreambuf_iterator<char>( _file ), ( std::istreambuf_iterator<char>() ) );
    const char *_source_str = _prog.c_str();
#ifdef __DEBUG__
    printf("Kernel to be compiled:\n%s\n", _source_str);
#endif
    _program = clCreateProgramWithSource(cl.context, 1, (const char **) &_source_str, 0, &_err );
    vglClCheckError(_err, (char*) "clCreateProgramWithSource" );
    _err = clBuildProgram(_program, 1, cl.deviceId, "-I CL_MM/", NULL, NULL );
    vglClBuildDebug(_err, _program);
  }

  static cl_kernel _kernel = NULL;
  if (_kernel == NULL)
  {
    _kernel = clCreateKernel( _program, "vglClFuzzyDaPDilate", &_err );
    vglClCheckError(_err, (char*) "clCreateKernel" );
  }


  _err = clSetKernelArg( _kernel, 0, sizeof( cl_mem ), (void*) &img_input->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 0" );

  _err = clSetKernelArg( _kernel, 1, sizeof( cl_mem ), (void*) &img_output->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 1" );

  _err = clSetKernelArg( _kernel, 2, sizeof( cl_mem ), (float*) &mobj_convolution_window );
  vglClCheckError( _err, (char*) "clSetKernelArg 2" );

  _err = clSetKernelArg( _kernel, 3, sizeof( int ), &window_size_x );
  vglClCheckError( _err, (char*) "clSetKernelArg 3" );

  _err = clSetKernelArg( _kernel, 4, sizeof( int ), &window_size_y );
  vglClCheckError( _err, (char*) "clSetKernelArg 4" );

  _err = clSetKernelArg( _kernel, 5, sizeof( float ), &gama );
  vglClCheckError( _err, (char*) "clSetKernelArg 5" );

  int _ndim = 2;
  if (img_input->ndim > 2){
    _ndim = 3;
  }

  size_t _worksize_0 = img_input->getWidthIn();
  if (img_input->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_input->getWidthStep();
  }
  if (img_output->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_output->getWidthStep();
  }

  size_t worksize[] = { _worksize_0, img_input->getHeightIn(),  img_input->getNFrames() };
  clEnqueueNDRangeKernel( cl.commandQueue, _kernel, _ndim, NULL, worksize, 0, 0, 0, 0 );

  vglClCheckError( _err, (char*) "clEnqueueNDRangeKernel" );

  _err = clReleaseMemObject( mobj_convolution_window );
  vglClCheckError(_err, (char*) "clReleaseMemObject mobj_convolution_window");

  vglSetContext(img_output, VGL_CL_CONTEXT);
}

/** Erosion of src image by mask. Result is stored in dst image.

  */
void vglClFuzzyDaPErode(VglImage* img_input, VglImage* img_output, float* convolution_window, int window_size_x, int window_size_y, float gama)
{
  vglCheckContext(img_input, VGL_CL_CONTEXT);
  vglCheckContext(img_output, VGL_CL_CONTEXT);

  cl_int _err;

  cl_mem mobj_convolution_window = NULL;
  mobj_convolution_window = clCreateBuffer(cl.context, CL_MEM_READ_ONLY, (window_size_x*window_size_y)*sizeof(float), NULL, &_err);
  vglClCheckError( _err, (char*) "clCreateBuffer convolution_window" );
  _err = clEnqueueWriteBuffer(cl.commandQueue, mobj_convolution_window, CL_TRUE, 0, (window_size_x*window_size_y)*sizeof(float), convolution_window, 0, NULL, NULL);
  vglClCheckError( _err, (char*) "clEnqueueWriteBuffer convolution_window" );

  static cl_program _program = NULL;
  if (_program == NULL)
  {
    char* _file_path = (char*) "CL_MM/vglClFuzzyDaPErode.cl";
    printf("Compiling %s\n", _file_path);
    std::ifstream _file(_file_path);
    if(_file.fail())
    {
      fprintf(stderr, "%s:%s: Error: File %s not found.\n", __FILE__, __FUNCTION__, _file_path);
      exit(1);
    }
    std::string _prog( std::istreambuf_iterator<char>( _file ), ( std::istreambuf_iterator<char>() ) );
    const char *_source_str = _prog.c_str();
#ifdef __DEBUG__
    printf("Kernel to be compiled:\n%s\n", _source_str);
#endif
    _program = clCreateProgramWithSource(cl.context, 1, (const char **) &_source_str, 0, &_err );
    vglClCheckError(_err, (char*) "clCreateProgramWithSource" );
    _err = clBuildProgram(_program, 1, cl.deviceId, "-I CL_MM/", NULL, NULL );
    vglClBuildDebug(_err, _program);
  }

  static cl_kernel _kernel = NULL;
  if (_kernel == NULL)
  {
    _kernel = clCreateKernel( _program, "vglClFuzzyDaPErode", &_err );
    vglClCheckError(_err, (char*) "clCreateKernel" );
  }


  _err = clSetKernelArg( _kernel, 0, sizeof( cl_mem ), (void*) &img_input->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 0" );

  _err = clSetKernelArg( _kernel, 1, sizeof( cl_mem ), (void*) &img_output->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 1" );

  _err = clSetKernelArg( _kernel, 2, sizeof( cl_mem ), (float*) &mobj_convolution_window );
  vglClCheckError( _err, (char*) "clSetKernelArg 2" );

  _err = clSetKernelArg( _kernel, 3, sizeof( int ), &window_size_x );
  vglClCheckError( _err, (char*) "clSetKernelArg 3" );

  _err = clSetKernelArg( _kernel, 4, sizeof( int ), &window_size_y );
  vglClCheckError( _err, (char*) "clSetKernelArg 4" );

  _err = clSetKernelArg( _kernel, 5, sizeof( float ), &gama );
  vglClCheckError( _err, (char*) "clSetKernelArg 5" );

  int _ndim = 2;
  if (img_input->ndim > 2){
    _ndim = 3;
  }

  size_t _worksize_0 = img_input->getWidthIn();
  if (img_input->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_input->getWidthStep();
  }
  if (img_output->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_output->getWidthStep();
  }

  size_t worksize[] = { _worksize_0, img_input->getHeightIn(),  img_input->getNFrames() };
  clEnqueueNDRangeKernel( cl.commandQueue, _kernel, _ndim, NULL, worksize, 0, 0, 0, 0 );

  vglClCheckError( _err, (char*) "clEnqueueNDRangeKernel" );

  _err = clReleaseMemObject( mobj_convolution_window );
  vglClCheckError(_err, (char*) "clReleaseMemObject mobj_convolution_window");

  vglSetContext(img_output, VGL_CL_CONTEXT);
}

/** Erosion of src image by mask. Result is stored in dst image.

  */
void vglClFuzzyDrasticDilate(VglImage* img_input, VglImage* img_output, float* convolution_window, int window_size_x, int window_size_y)
{
  vglCheckContext(img_input, VGL_CL_CONTEXT);
  vglCheckContext(img_output, VGL_CL_CONTEXT);

  cl_int _err;

  cl_mem mobj_convolution_window = NULL;
  mobj_convolution_window = clCreateBuffer(cl.context, CL_MEM_READ_ONLY, (window_size_x*window_size_y)*sizeof(float), NULL, &_err);
  vglClCheckError( _err, (char*) "clCreateBuffer convolution_window" );
  _err = clEnqueueWriteBuffer(cl.commandQueue, mobj_convolution_window, CL_TRUE, 0, (window_size_x*window_size_y)*sizeof(float), convolution_window, 0, NULL, NULL);
  vglClCheckError( _err, (char*) "clEnqueueWriteBuffer convolution_window" );

  static cl_program _program = NULL;
  if (_program == NULL)
  {
    char* _file_path = (char*) "CL_MM/vglClFuzzyDrasticDilate.cl";
    printf("Compiling %s\n", _file_path);
    std::ifstream _file(_file_path);
    if(_file.fail())
    {
      fprintf(stderr, "%s:%s: Error: File %s not found.\n", __FILE__, __FUNCTION__, _file_path);
      exit(1);
    }
    std::string _prog( std::istreambuf_iterator<char>( _file ), ( std::istreambuf_iterator<char>() ) );
    const char *_source_str = _prog.c_str();
#ifdef __DEBUG__
    printf("Kernel to be compiled:\n%s\n", _source_str);
#endif
    _program = clCreateProgramWithSource(cl.context, 1, (const char **) &_source_str, 0, &_err );
    vglClCheckError(_err, (char*) "clCreateProgramWithSource" );
    _err = clBuildProgram(_program, 1, cl.deviceId, "-I CL_MM/", NULL, NULL );
    vglClBuildDebug(_err, _program);
  }

  static cl_kernel _kernel = NULL;
  if (_kernel == NULL)
  {
    _kernel = clCreateKernel( _program, "vglClFuzzyDrasticDilate", &_err );
    vglClCheckError(_err, (char*) "clCreateKernel" );
  }


  _err = clSetKernelArg( _kernel, 0, sizeof( cl_mem ), (void*) &img_input->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 0" );

  _err = clSetKernelArg( _kernel, 1, sizeof( cl_mem ), (void*) &img_output->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 1" );

  _err = clSetKernelArg( _kernel, 2, sizeof( cl_mem ), (float*) &mobj_convolution_window );
  vglClCheckError( _err, (char*) "clSetKernelArg 2" );

  _err = clSetKernelArg( _kernel, 3, sizeof( int ), &window_size_x );
  vglClCheckError( _err, (char*) "clSetKernelArg 3" );

  _err = clSetKernelArg( _kernel, 4, sizeof( int ), &window_size_y );
  vglClCheckError( _err, (char*) "clSetKernelArg 4" );

  int _ndim = 2;
  if (img_input->ndim > 2){
    _ndim = 3;
  }

  size_t _worksize_0 = img_input->getWidthIn();
  if (img_input->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_input->getWidthStep();
  }
  if (img_output->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_output->getWidthStep();
  }

  size_t worksize[] = { _worksize_0, img_input->getHeightIn(),  img_input->getNFrames() };
  clEnqueueNDRangeKernel( cl.commandQueue, _kernel, _ndim, NULL, worksize, 0, 0, 0, 0 );

  vglClCheckError( _err, (char*) "clEnqueueNDRangeKernel" );

  _err = clReleaseMemObject( mobj_convolution_window );
  vglClCheckError(_err, (char*) "clReleaseMemObject mobj_convolution_window");

  vglSetContext(img_output, VGL_CL_CONTEXT);
}

/** Erosion of src image by mask. Result is stored in dst image.

  */
void vglClFuzzyDrasticErode(VglImage* img_input, VglImage* img_output, float* convolution_window, int window_size_x, int window_size_y)
{
  vglCheckContext(img_input, VGL_CL_CONTEXT);
  vglCheckContext(img_output, VGL_CL_CONTEXT);

  cl_int _err;

  cl_mem mobj_convolution_window = NULL;
  mobj_convolution_window = clCreateBuffer(cl.context, CL_MEM_READ_ONLY, (window_size_x*window_size_y)*sizeof(float), NULL, &_err);
  vglClCheckError( _err, (char*) "clCreateBuffer convolution_window" );
  _err = clEnqueueWriteBuffer(cl.commandQueue, mobj_convolution_window, CL_TRUE, 0, (window_size_x*window_size_y)*sizeof(float), convolution_window, 0, NULL, NULL);
  vglClCheckError( _err, (char*) "clEnqueueWriteBuffer convolution_window" );

  static cl_program _program = NULL;
  if (_program == NULL)
  {
    char* _file_path = (char*) "CL_MM/vglClFuzzyDrasticErode.cl";
    printf("Compiling %s\n", _file_path);
    std::ifstream _file(_file_path);
    if(_file.fail())
    {
      fprintf(stderr, "%s:%s: Error: File %s not found.\n", __FILE__, __FUNCTION__, _file_path);
      exit(1);
    }
    std::string _prog( std::istreambuf_iterator<char>( _file ), ( std::istreambuf_iterator<char>() ) );
    const char *_source_str = _prog.c_str();
#ifdef __DEBUG__
    printf("Kernel to be compiled:\n%s\n", _source_str);
#endif
    _program = clCreateProgramWithSource(cl.context, 1, (const char **) &_source_str, 0, &_err );
    vglClCheckError(_err, (char*) "clCreateProgramWithSource" );
    _err = clBuildProgram(_program, 1, cl.deviceId, "-I CL_MM/", NULL, NULL );
    vglClBuildDebug(_err, _program);
  }

  static cl_kernel _kernel = NULL;
  if (_kernel == NULL)
  {
    _kernel = clCreateKernel( _program, "vglClFuzzyDrasticErode", &_err );
    vglClCheckError(_err, (char*) "clCreateKernel" );
  }


  _err = clSetKernelArg( _kernel, 0, sizeof( cl_mem ), (void*) &img_input->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 0" );

  _err = clSetKernelArg( _kernel, 1, sizeof( cl_mem ), (void*) &img_output->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 1" );

  _err = clSetKernelArg( _kernel, 2, sizeof( cl_mem ), (float*) &mobj_convolution_window );
  vglClCheckError( _err, (char*) "clSetKernelArg 2" );

  _err = clSetKernelArg( _kernel, 3, sizeof( int ), &window_size_x );
  vglClCheckError( _err, (char*) "clSetKernelArg 3" );

  _err = clSetKernelArg( _kernel, 4, sizeof( int ), &window_size_y );
  vglClCheckError( _err, (char*) "clSetKernelArg 4" );

  int _ndim = 2;
  if (img_input->ndim > 2){
    _ndim = 3;
  }

  size_t _worksize_0 = img_input->getWidthIn();
  if (img_input->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_input->getWidthStep();
  }
  if (img_output->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_output->getWidthStep();
  }

  size_t worksize[] = { _worksize_0, img_input->getHeightIn(),  img_input->getNFrames() };
  clEnqueueNDRangeKernel( cl.commandQueue, _kernel, _ndim, NULL, worksize, 0, 0, 0, 0 );

  vglClCheckError( _err, (char*) "clEnqueueNDRangeKernel" );

  _err = clReleaseMemObject( mobj_convolution_window );
  vglClCheckError(_err, (char*) "clReleaseMemObject mobj_convolution_window");

  vglSetContext(img_output, VGL_CL_CONTEXT);
}

/** Erosion of src image by mask. Result is stored in dst image.

  */
void vglClFuzzyGeoDilate(VglImage* img_input, VglImage* img_output, float* convolution_window, int window_size_x, int window_size_y)
{
  vglCheckContext(img_input, VGL_CL_CONTEXT);
  vglCheckContext(img_output, VGL_CL_CONTEXT);

  cl_int _err;

  cl_mem mobj_convolution_window = NULL;
  mobj_convolution_window = clCreateBuffer(cl.context, CL_MEM_READ_ONLY, (window_size_x*window_size_y)*sizeof(float), NULL, &_err);
  vglClCheckError( _err, (char*) "clCreateBuffer convolution_window" );
  _err = clEnqueueWriteBuffer(cl.commandQueue, mobj_convolution_window, CL_TRUE, 0, (window_size_x*window_size_y)*sizeof(float), convolution_window, 0, NULL, NULL);
  vglClCheckError( _err, (char*) "clEnqueueWriteBuffer convolution_window" );

  static cl_program _program = NULL;
  if (_program == NULL)
  {
    char* _file_path = (char*) "CL_MM/vglClFuzzyGeoDilate.cl";
    printf("Compiling %s\n", _file_path);
    std::ifstream _file(_file_path);
    if(_file.fail())
    {
      fprintf(stderr, "%s:%s: Error: File %s not found.\n", __FILE__, __FUNCTION__, _file_path);
      exit(1);
    }
    std::string _prog( std::istreambuf_iterator<char>( _file ), ( std::istreambuf_iterator<char>() ) );
    const char *_source_str = _prog.c_str();
#ifdef __DEBUG__
    printf("Kernel to be compiled:\n%s\n", _source_str);
#endif
    _program = clCreateProgramWithSource(cl.context, 1, (const char **) &_source_str, 0, &_err );
    vglClCheckError(_err, (char*) "clCreateProgramWithSource" );
    _err = clBuildProgram(_program, 1, cl.deviceId, "-I CL_MM/", NULL, NULL );
    vglClBuildDebug(_err, _program);
  }

  static cl_kernel _kernel = NULL;
  if (_kernel == NULL)
  {
    _kernel = clCreateKernel( _program, "vglClFuzzyGeoDilate", &_err );
    vglClCheckError(_err, (char*) "clCreateKernel" );
  }


  _err = clSetKernelArg( _kernel, 0, sizeof( cl_mem ), (void*) &img_input->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 0" );

  _err = clSetKernelArg( _kernel, 1, sizeof( cl_mem ), (void*) &img_output->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 1" );

  _err = clSetKernelArg( _kernel, 2, sizeof( cl_mem ), (float*) &mobj_convolution_window );
  vglClCheckError( _err, (char*) "clSetKernelArg 2" );

  _err = clSetKernelArg( _kernel, 3, sizeof( int ), &window_size_x );
  vglClCheckError( _err, (char*) "clSetKernelArg 3" );

  _err = clSetKernelArg( _kernel, 4, sizeof( int ), &window_size_y );
  vglClCheckError( _err, (char*) "clSetKernelArg 4" );

  int _ndim = 2;
  if (img_input->ndim > 2){
    _ndim = 3;
  }

  size_t _worksize_0 = img_input->getWidthIn();
  if (img_input->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_input->getWidthStep();
  }
  if (img_output->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_output->getWidthStep();
  }

  size_t worksize[] = { _worksize_0, img_input->getHeightIn(),  img_input->getNFrames() };
  clEnqueueNDRangeKernel( cl.commandQueue, _kernel, _ndim, NULL, worksize, 0, 0, 0, 0 );

  vglClCheckError( _err, (char*) "clEnqueueNDRangeKernel" );

  _err = clReleaseMemObject( mobj_convolution_window );
  vglClCheckError(_err, (char*) "clReleaseMemObject mobj_convolution_window");

  vglSetContext(img_output, VGL_CL_CONTEXT);
}

/** Erosion of src image by mask. Result is stored in dst image.

  */
void vglClFuzzyGeoErode(VglImage* img_input, VglImage* img_output, float* convolution_window, int window_size_x, int window_size_y)
{
  vglCheckContext(img_input, VGL_CL_CONTEXT);
  vglCheckContext(img_output, VGL_CL_CONTEXT);

  cl_int _err;

  cl_mem mobj_convolution_window = NULL;
  mobj_convolution_window = clCreateBuffer(cl.context, CL_MEM_READ_ONLY, (window_size_x*window_size_y)*sizeof(float), NULL, &_err);
  vglClCheckError( _err, (char*) "clCreateBuffer convolution_window" );
  _err = clEnqueueWriteBuffer(cl.commandQueue, mobj_convolution_window, CL_TRUE, 0, (window_size_x*window_size_y)*sizeof(float), convolution_window, 0, NULL, NULL);
  vglClCheckError( _err, (char*) "clEnqueueWriteBuffer convolution_window" );

  static cl_program _program = NULL;
  if (_program == NULL)
  {
    char* _file_path = (char*) "CL_MM/vglClFuzzyGeoErode.cl";
    printf("Compiling %s\n", _file_path);
    std::ifstream _file(_file_path);
    if(_file.fail())
    {
      fprintf(stderr, "%s:%s: Error: File %s not found.\n", __FILE__, __FUNCTION__, _file_path);
      exit(1);
    }
    std::string _prog( std::istreambuf_iterator<char>( _file ), ( std::istreambuf_iterator<char>() ) );
    const char *_source_str = _prog.c_str();
#ifdef __DEBUG__
    printf("Kernel to be compiled:\n%s\n", _source_str);
#endif
    _program = clCreateProgramWithSource(cl.context, 1, (const char **) &_source_str, 0, &_err );
    vglClCheckError(_err, (char*) "clCreateProgramWithSource" );
    _err = clBuildProgram(_program, 1, cl.deviceId, "-I CL_MM/", NULL, NULL );
    vglClBuildDebug(_err, _program);
  }

  static cl_kernel _kernel = NULL;
  if (_kernel == NULL)
  {
    _kernel = clCreateKernel( _program, "vglClFuzzyGeoErode", &_err );
    vglClCheckError(_err, (char*) "clCreateKernel" );
  }


  _err = clSetKernelArg( _kernel, 0, sizeof( cl_mem ), (void*) &img_input->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 0" );

  _err = clSetKernelArg( _kernel, 1, sizeof( cl_mem ), (void*) &img_output->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 1" );

  _err = clSetKernelArg( _kernel, 2, sizeof( cl_mem ), (float*) &mobj_convolution_window );
  vglClCheckError( _err, (char*) "clSetKernelArg 2" );

  _err = clSetKernelArg( _kernel, 3, sizeof( int ), &window_size_x );
  vglClCheckError( _err, (char*) "clSetKernelArg 3" );

  _err = clSetKernelArg( _kernel, 4, sizeof( int ), &window_size_y );
  vglClCheckError( _err, (char*) "clSetKernelArg 4" );

  int _ndim = 2;
  if (img_input->ndim > 2){
    _ndim = 3;
  }

  size_t _worksize_0 = img_input->getWidthIn();
  if (img_input->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_input->getWidthStep();
  }
  if (img_output->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_output->getWidthStep();
  }

  size_t worksize[] = { _worksize_0, img_input->getHeightIn(),  img_input->getNFrames() };
  clEnqueueNDRangeKernel( cl.commandQueue, _kernel, _ndim, NULL, worksize, 0, 0, 0, 0 );

  vglClCheckError( _err, (char*) "clEnqueueNDRangeKernel" );

  _err = clReleaseMemObject( mobj_convolution_window );
  vglClCheckError(_err, (char*) "clReleaseMemObject mobj_convolution_window");

  vglSetContext(img_output, VGL_CL_CONTEXT);
}

/** Erosion of src image by mask. Result is stored in dst image.

  */
void vglClFuzzyHamacherDilate(VglImage* img_input, VglImage* img_output, float* convolution_window, int window_size_x, int window_size_y, float gama)
{
  vglCheckContext(img_input, VGL_CL_CONTEXT);
  vglCheckContext(img_output, VGL_CL_CONTEXT);

  cl_int _err;

  cl_mem mobj_convolution_window = NULL;
  mobj_convolution_window = clCreateBuffer(cl.context, CL_MEM_READ_ONLY, (window_size_x*window_size_y)*sizeof(float), NULL, &_err);
  vglClCheckError( _err, (char*) "clCreateBuffer convolution_window" );
  _err = clEnqueueWriteBuffer(cl.commandQueue, mobj_convolution_window, CL_TRUE, 0, (window_size_x*window_size_y)*sizeof(float), convolution_window, 0, NULL, NULL);
  vglClCheckError( _err, (char*) "clEnqueueWriteBuffer convolution_window" );

  static cl_program _program = NULL;
  if (_program == NULL)
  {
    char* _file_path = (char*) "CL_MM/vglClFuzzyHamacherDilate.cl";
    printf("Compiling %s\n", _file_path);
    std::ifstream _file(_file_path);
    if(_file.fail())
    {
      fprintf(stderr, "%s:%s: Error: File %s not found.\n", __FILE__, __FUNCTION__, _file_path);
      exit(1);
    }
    std::string _prog( std::istreambuf_iterator<char>( _file ), ( std::istreambuf_iterator<char>() ) );
    const char *_source_str = _prog.c_str();
#ifdef __DEBUG__
    printf("Kernel to be compiled:\n%s\n", _source_str);
#endif
    _program = clCreateProgramWithSource(cl.context, 1, (const char **) &_source_str, 0, &_err );
    vglClCheckError(_err, (char*) "clCreateProgramWithSource" );
    _err = clBuildProgram(_program, 1, cl.deviceId, "-I CL_MM/", NULL, NULL );
    vglClBuildDebug(_err, _program);
  }

  static cl_kernel _kernel = NULL;
  if (_kernel == NULL)
  {
    _kernel = clCreateKernel( _program, "vglClFuzzyHamacherDilate", &_err );
    vglClCheckError(_err, (char*) "clCreateKernel" );
  }


  _err = clSetKernelArg( _kernel, 0, sizeof( cl_mem ), (void*) &img_input->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 0" );

  _err = clSetKernelArg( _kernel, 1, sizeof( cl_mem ), (void*) &img_output->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 1" );

  _err = clSetKernelArg( _kernel, 2, sizeof( cl_mem ), (float*) &mobj_convolution_window );
  vglClCheckError( _err, (char*) "clSetKernelArg 2" );

  _err = clSetKernelArg( _kernel, 3, sizeof( int ), &window_size_x );
  vglClCheckError( _err, (char*) "clSetKernelArg 3" );

  _err = clSetKernelArg( _kernel, 4, sizeof( int ), &window_size_y );
  vglClCheckError( _err, (char*) "clSetKernelArg 4" );

  _err = clSetKernelArg( _kernel, 5, sizeof( float ), &gama );
  vglClCheckError( _err, (char*) "clSetKernelArg 5" );

  int _ndim = 2;
  if (img_input->ndim > 2){
    _ndim = 3;
  }

  size_t _worksize_0 = img_input->getWidthIn();
  if (img_input->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_input->getWidthStep();
  }
  if (img_output->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_output->getWidthStep();
  }

  size_t worksize[] = { _worksize_0, img_input->getHeightIn(),  img_input->getNFrames() };
  clEnqueueNDRangeKernel( cl.commandQueue, _kernel, _ndim, NULL, worksize, 0, 0, 0, 0 );

  vglClCheckError( _err, (char*) "clEnqueueNDRangeKernel" );

  _err = clReleaseMemObject( mobj_convolution_window );
  vglClCheckError(_err, (char*) "clReleaseMemObject mobj_convolution_window");

  vglSetContext(img_output, VGL_CL_CONTEXT);
}

/** Erosion of src image by mask. Result is stored in dst image.

  */
void vglClFuzzyHamacherErode(VglImage* img_input, VglImage* img_output, float* convolution_window, int window_size_x, int window_size_y, float gama)
{
  vglCheckContext(img_input, VGL_CL_CONTEXT);
  vglCheckContext(img_output, VGL_CL_CONTEXT);

  cl_int _err;

  cl_mem mobj_convolution_window = NULL;
  mobj_convolution_window = clCreateBuffer(cl.context, CL_MEM_READ_ONLY, (window_size_x*window_size_y)*sizeof(float), NULL, &_err);
  vglClCheckError( _err, (char*) "clCreateBuffer convolution_window" );
  _err = clEnqueueWriteBuffer(cl.commandQueue, mobj_convolution_window, CL_TRUE, 0, (window_size_x*window_size_y)*sizeof(float), convolution_window, 0, NULL, NULL);
  vglClCheckError( _err, (char*) "clEnqueueWriteBuffer convolution_window" );

  static cl_program _program = NULL;
  if (_program == NULL)
  {
    char* _file_path = (char*) "CL_MM/vglClFuzzyHamacherErode.cl";
    printf("Compiling %s\n", _file_path);
    std::ifstream _file(_file_path);
    if(_file.fail())
    {
      fprintf(stderr, "%s:%s: Error: File %s not found.\n", __FILE__, __FUNCTION__, _file_path);
      exit(1);
    }
    std::string _prog( std::istreambuf_iterator<char>( _file ), ( std::istreambuf_iterator<char>() ) );
    const char *_source_str = _prog.c_str();
#ifdef __DEBUG__
    printf("Kernel to be compiled:\n%s\n", _source_str);
#endif
    _program = clCreateProgramWithSource(cl.context, 1, (const char **) &_source_str, 0, &_err );
    vglClCheckError(_err, (char*) "clCreateProgramWithSource" );
    _err = clBuildProgram(_program, 1, cl.deviceId, "-I CL_MM/", NULL, NULL );
    vglClBuildDebug(_err, _program);
  }

  static cl_kernel _kernel = NULL;
  if (_kernel == NULL)
  {
    _kernel = clCreateKernel( _program, "vglClFuzzyHamacherErode", &_err );
    vglClCheckError(_err, (char*) "clCreateKernel" );
  }


  _err = clSetKernelArg( _kernel, 0, sizeof( cl_mem ), (void*) &img_input->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 0" );

  _err = clSetKernelArg( _kernel, 1, sizeof( cl_mem ), (void*) &img_output->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 1" );

  _err = clSetKernelArg( _kernel, 2, sizeof( cl_mem ), (float*) &mobj_convolution_window );
  vglClCheckError( _err, (char*) "clSetKernelArg 2" );

  _err = clSetKernelArg( _kernel, 3, sizeof( int ), &window_size_x );
  vglClCheckError( _err, (char*) "clSetKernelArg 3" );

  _err = clSetKernelArg( _kernel, 4, sizeof( int ), &window_size_y );
  vglClCheckError( _err, (char*) "clSetKernelArg 4" );

  _err = clSetKernelArg( _kernel, 5, sizeof( float ), &gama );
  vglClCheckError( _err, (char*) "clSetKernelArg 5" );

  int _ndim = 2;
  if (img_input->ndim > 2){
    _ndim = 3;
  }

  size_t _worksize_0 = img_input->getWidthIn();
  if (img_input->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_input->getWidthStep();
  }
  if (img_output->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_output->getWidthStep();
  }

  size_t worksize[] = { _worksize_0, img_input->getHeightIn(),  img_input->getNFrames() };
  clEnqueueNDRangeKernel( cl.commandQueue, _kernel, _ndim, NULL, worksize, 0, 0, 0, 0 );

  vglClCheckError( _err, (char*) "clEnqueueNDRangeKernel" );

  _err = clReleaseMemObject( mobj_convolution_window );
  vglClCheckError(_err, (char*) "clReleaseMemObject mobj_convolution_window");

  vglSetContext(img_output, VGL_CL_CONTEXT);
}

/** Erosion of src image by mask. Result is stored in dst image.

  */
void vglClFuzzyStdDilate(VglImage* img_input, VglImage* img_output, float* convolution_window, int window_size_x, int window_size_y)
{
  vglCheckContext(img_input, VGL_CL_CONTEXT);
  vglCheckContext(img_output, VGL_CL_CONTEXT);

  cl_int _err;

  cl_mem mobj_convolution_window = NULL;
  mobj_convolution_window = clCreateBuffer(cl.context, CL_MEM_READ_ONLY, (window_size_x*window_size_y)*sizeof(float), NULL, &_err);
  vglClCheckError( _err, (char*) "clCreateBuffer convolution_window" );
  _err = clEnqueueWriteBuffer(cl.commandQueue, mobj_convolution_window, CL_TRUE, 0, (window_size_x*window_size_y)*sizeof(float), convolution_window, 0, NULL, NULL);
  vglClCheckError( _err, (char*) "clEnqueueWriteBuffer convolution_window" );

  static cl_program _program = NULL;
  if (_program == NULL)
  {
    char* _file_path = (char*) "CL_MM/vglClFuzzyStdDilate.cl";
    printf("Compiling %s\n", _file_path);
    std::ifstream _file(_file_path);
    if(_file.fail())
    {
      fprintf(stderr, "%s:%s: Error: File %s not found.\n", __FILE__, __FUNCTION__, _file_path);
      exit(1);
    }
    std::string _prog( std::istreambuf_iterator<char>( _file ), ( std::istreambuf_iterator<char>() ) );
    const char *_source_str = _prog.c_str();
#ifdef __DEBUG__
    printf("Kernel to be compiled:\n%s\n", _source_str);
#endif
    _program = clCreateProgramWithSource(cl.context, 1, (const char **) &_source_str, 0, &_err );
    vglClCheckError(_err, (char*) "clCreateProgramWithSource" );
    _err = clBuildProgram(_program, 1, cl.deviceId, "-I CL_MM/", NULL, NULL );
    vglClBuildDebug(_err, _program);
  }

  static cl_kernel _kernel = NULL;
  if (_kernel == NULL)
  {
    _kernel = clCreateKernel( _program, "vglClFuzzyStdDilate", &_err );
    vglClCheckError(_err, (char*) "clCreateKernel" );
  }


  _err = clSetKernelArg( _kernel, 0, sizeof( cl_mem ), (void*) &img_input->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 0" );

  _err = clSetKernelArg( _kernel, 1, sizeof( cl_mem ), (void*) &img_output->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 1" );

  _err = clSetKernelArg( _kernel, 2, sizeof( cl_mem ), (float*) &mobj_convolution_window );
  vglClCheckError( _err, (char*) "clSetKernelArg 2" );

  _err = clSetKernelArg( _kernel, 3, sizeof( int ), &window_size_x );
  vglClCheckError( _err, (char*) "clSetKernelArg 3" );

  _err = clSetKernelArg( _kernel, 4, sizeof( int ), &window_size_y );
  vglClCheckError( _err, (char*) "clSetKernelArg 4" );

  int _ndim = 2;
  if (img_input->ndim > 2){
    _ndim = 3;
  }

  size_t _worksize_0 = img_input->getWidthIn();
  if (img_input->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_input->getWidthStep();
  }
  if (img_output->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_output->getWidthStep();
  }

  size_t worksize[] = { _worksize_0, img_input->getHeightIn(),  img_input->getNFrames() };
  clEnqueueNDRangeKernel( cl.commandQueue, _kernel, _ndim, NULL, worksize, 0, 0, 0, 0 );

  vglClCheckError( _err, (char*) "clEnqueueNDRangeKernel" );

  _err = clReleaseMemObject( mobj_convolution_window );
  vglClCheckError(_err, (char*) "clReleaseMemObject mobj_convolution_window");

  vglSetContext(img_output, VGL_CL_CONTEXT);
}

/** Erosion of src image by mask. Result is stored in dst image.

  */
void vglClFuzzyStdErode(VglImage* img_input, VglImage* img_output, float* convolution_window, int window_size_x, int window_size_y)
{
  vglCheckContext(img_input, VGL_CL_CONTEXT);
  vglCheckContext(img_output, VGL_CL_CONTEXT);

  cl_int _err;

  cl_mem mobj_convolution_window = NULL;
  mobj_convolution_window = clCreateBuffer(cl.context, CL_MEM_READ_ONLY, (window_size_x*window_size_y)*sizeof(float), NULL, &_err);
  vglClCheckError( _err, (char*) "clCreateBuffer convolution_window" );
  _err = clEnqueueWriteBuffer(cl.commandQueue, mobj_convolution_window, CL_TRUE, 0, (window_size_x*window_size_y)*sizeof(float), convolution_window, 0, NULL, NULL);
  vglClCheckError( _err, (char*) "clEnqueueWriteBuffer convolution_window" );

  static cl_program _program = NULL;
  if (_program == NULL)
  {
    char* _file_path = (char*) "CL_MM/vglClFuzzyStdErode.cl";
    printf("Compiling %s\n", _file_path);
    std::ifstream _file(_file_path);
    if(_file.fail())
    {
      fprintf(stderr, "%s:%s: Error: File %s not found.\n", __FILE__, __FUNCTION__, _file_path);
      exit(1);
    }
    std::string _prog( std::istreambuf_iterator<char>( _file ), ( std::istreambuf_iterator<char>() ) );
    const char *_source_str = _prog.c_str();
#ifdef __DEBUG__
    printf("Kernel to be compiled:\n%s\n", _source_str);
#endif
    _program = clCreateProgramWithSource(cl.context, 1, (const char **) &_source_str, 0, &_err );
    vglClCheckError(_err, (char*) "clCreateProgramWithSource" );
    _err = clBuildProgram(_program, 1, cl.deviceId, "-I CL_MM/", NULL, NULL );
    vglClBuildDebug(_err, _program);
  }

  static cl_kernel _kernel = NULL;
  if (_kernel == NULL)
  {
    _kernel = clCreateKernel( _program, "vglClFuzzyStdErode", &_err );
    vglClCheckError(_err, (char*) "clCreateKernel" );
  }


  _err = clSetKernelArg( _kernel, 0, sizeof( cl_mem ), (void*) &img_input->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 0" );

  _err = clSetKernelArg( _kernel, 1, sizeof( cl_mem ), (void*) &img_output->oclPtr );
  vglClCheckError( _err, (char*) "clSetKernelArg 1" );

  _err = clSetKernelArg( _kernel, 2, sizeof( cl_mem ), (float*) &mobj_convolution_window );
  vglClCheckError( _err, (char*) "clSetKernelArg 2" );

  _err = clSetKernelArg( _kernel, 3, sizeof( int ), &window_size_x );
  vglClCheckError( _err, (char*) "clSetKernelArg 3" );

  _err = clSetKernelArg( _kernel, 4, sizeof( int ), &window_size_y );
  vglClCheckError( _err, (char*) "clSetKernelArg 4" );

  int _ndim = 2;
  if (img_input->ndim > 2){
    _ndim = 3;
  }

  size_t _worksize_0 = img_input->getWidthIn();
  if (img_input->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_input->getWidthStep();
  }
  if (img_output->depth == IPL_DEPTH_1U)
  {
    _worksize_0 = img_output->getWidthStep();
  }

  size_t worksize[] = { _worksize_0, img_input->getHeightIn(),  img_input->getNFrames() };
  clEnqueueNDRangeKernel( cl.commandQueue, _kernel, _ndim, NULL, worksize, 0, 0, 0, 0 );

  vglClCheckError( _err, (char*) "clEnqueueNDRangeKernel" );

  _err = clReleaseMemObject( mobj_convolution_window );
  vglClCheckError(_err, (char*) "clReleaseMemObject mobj_convolution_window");

  vglSetContext(img_output, VGL_CL_CONTEXT);
}

