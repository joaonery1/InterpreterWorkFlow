
/*********************************************************************
***                                                                 ***
***  Source code generated by kernel2cu.pl                          ***
***                                                                 ***
***  Please do not edit                                             ***
***                                                                 ***
*********************************************************************/

#include "vglImage.h"
#include "vglLoadShader.h"
#include "vglContext.h"

#include <iostream>

//kernels

/** vglCudaCopy

    Copy of image in cuda context.
*/

// <<<input->getHeight(),384>>> (IO_PBO: VglImage* input, IO_PBO: VglImage* output)
// (input->cudaPtr, output->cudaPtr, input->getWidth(), input->getHeight(), input->nChannels)

template<typename T> 
__global__ void global_Copy(T* input, T* output, int w, int h, int nChannels){
    int offset = blockIdx.x * nChannels * w;
    T* arr_in  = input + offset;
    T* arr_out = output + offset;
    for (int j = threadIdx.x; j < nChannels * w; j += blockDim.x){
      arr_out[j] = arr_in[j];
    }
}

void vglCudaCopy(VglImage* input, VglImage* output){
    if (!input){
      printf("vglCudaCopy: Error: input parameter is null in file '%s' in line %i.\n",
              __FILE__, __LINE__);
      exit(1);
    }
    vglCheckContext(input, VGL_CUDA_CONTEXT);
    if (!input->cudaPtr){
      printf("vglCudaCopy: Error: input->cudaPtr is null in file '%s' in line %i.\n",
              __FILE__, __LINE__);
      exit(1);
    }

    if (!output){
      printf("vglCudaCopy: Error: output parameter is null in file '%s' in line %i.\n",
              __FILE__, __LINE__);
      exit(1);
    }
    vglCheckContext(output, VGL_CUDA_CONTEXT);
    if (!output->cudaPtr){
      printf("vglCudaCopy: Error: output->cudaPtr is null in file '%s' in line %i.\n",
              __FILE__, __LINE__);
      exit(1);
    }


    switch (input->depth){
      case (IPL_DEPTH_8U):
        global_Copy<<<input->getHeight(),384>>>((unsigned char*)input->cudaPtr, (unsigned char*)output->cudaPtr, input->getWidth(), input->getHeight(), input->nChannels);
        break;
      default:
        printf("vglCudaCopy: Error: unsupported img->depth = %d in file '%s' in line %i.\n",
                input->depth, __FILE__, __LINE__);
        exit(1);
    }

    vglSetContext(input, VGL_CUDA_CONTEXT);
    vglSetContext(output, VGL_CUDA_CONTEXT);
}


/** vglCudaInvert

    Inverts image stored in cuda context.
*/

// <<<input->getWidth(),384>>> (IN_PBO: VglImage* input, OUT_PBO: VglImage* output)
// (input->cudaPtr, output->cudaPtr, input->getWidth(), input->getHeight(), input->nChannels)

template<typename T> 
__global__ void global_Invert(T* input, T* output, int w, int h, int nChannels){
    int offset = blockIdx.x * nChannels * w;
    T* array_in  = input  + offset;
    T* array_out = output + offset;
    for (int j = threadIdx.x; j < nChannels * w; j += blockDim.x){
      array_out[j] = -array_in[j];
    }
}

void vglCudaInvert(VglImage* input, VglImage* output){
    if (!input){
      printf("vglCudaInvert: Error: input parameter is null in file '%s' in line %i.\n",
              __FILE__, __LINE__);
      exit(1);
    }
    vglCheckContext(input, VGL_CUDA_CONTEXT);
    if (!input->cudaPtr){
      printf("vglCudaInvert: Error: input->cudaPtr is null in file '%s' in line %i.\n",
              __FILE__, __LINE__);
      exit(1);
    }

    if (!output){
      printf("vglCudaInvert: Error: output parameter is null in file '%s' in line %i.\n",
              __FILE__, __LINE__);
      exit(1);
    }
    vglCheckContextForOutput(output, VGL_CUDA_CONTEXT);
    if (!output->cudaPtr){
      printf("vglCudaInvert: Error: output->cudaPtr is null in file '%s' in line %i.\n",
              __FILE__, __LINE__);
      exit(1);
    }


    switch (input->depth){
      case (IPL_DEPTH_8U):
        global_Invert<<<input->getWidth(),384>>>((unsigned char*)input->cudaPtr, (unsigned char*)output->cudaPtr, input->getWidth(), input->getHeight(), input->nChannels);
        break;
      default:
        printf("vglCudaInvert: Error: unsupported img->depth = %d in file '%s' in line %i.\n",
                input->depth, __FILE__, __LINE__);
        exit(1);
    }

    vglSetContext(output, VGL_CUDA_CONTEXT);
}




/** vglCudaInvertOnPlace

    Inverts image, stored in cuda context, on place.
*/

// <<<input->getHeight(),384>>> (IO_PBO: VglImage* input)
// (input->cudaPtr, input->getWidth(), input->getHeight(), input->nChannels)

  template<typename T> 
  __global__ void global_InvertOnPlace(T* input, int w, int h, int nChannels){
    T* array = input + blockIdx.x * nChannels * w;
    for (int j = threadIdx.x; j < nChannels * w; j += blockDim.x){
      array[j] = -array[j];
    }
  }

void vglCudaInvertOnPlace(VglImage* input){
    if (!input){
      printf("vglCudaInvertOnPlace: Error: input parameter is null in file '%s' in line %i.\n",
              __FILE__, __LINE__);
      exit(1);
    }
    vglCheckContext(input, VGL_CUDA_CONTEXT);
    if (!input->cudaPtr){
      printf("vglCudaInvertOnPlace: Error: input->cudaPtr is null in file '%s' in line %i.\n",
              __FILE__, __LINE__);
      exit(1);
    }


    switch (input->depth){
      case (IPL_DEPTH_8U):
        global_InvertOnPlace<<<input->getHeight(),384>>>((unsigned char*)input->cudaPtr, input->getWidth(), input->getHeight(), input->nChannels);
        break;
      default:
        printf("vglCudaInvertOnPlace: Error: unsupported img->depth = %d in file '%s' in line %i.\n",
                input->depth, __FILE__, __LINE__);
        exit(1);
    }

    vglSetContext(input, VGL_CUDA_CONTEXT);
}

