
/*********************************************************************
***                                                                 ***
***  Source code generated by glsl2cpp.pl                           ***
***                                                                 ***
***  Please do not edit                                             ***
***                                                                 ***
*********************************************************************/
#include "vglImage.h"
/** Calculate absolute difference between img_ref and img_2. Disparities considered are in the closed interval [4*disparity, 4*disparity+3].

    The four differences are stored in the RGBA image dst.

  */
void vglAbsDiffDisparity(VglImage* img_ref, VglImage* img_2, VglImage* dst, float disparity);

/** Calculates average absolute difference between img_ref and img_2 at levels of detail in [0, max_lod]. Disparities considered are in the closed interval [4*disparity, 4*disparity+3].

    The four differences are stored in the RGBA image dst.

  */
void vglAbsDiffDisparityMipmap(VglImage* img_ref, VglImage* img_2, VglImage* dst, float disparity, float max_lod);

/** Find best disparity. The first input image, img_dif, contains absolute differences between a pair of images at disparities [4*disparity, 4*disparity+3]. 

    The second input image contains the smallest differences found in channel R, and corresponding disparity value in channel A, Is also an output image, and is updated whenever a smaller difference is found.

  */
void vglFindDisparity(VglImage* img_dif, VglImage* img_disp, float disparity);

/** Do the same as vglFindDisparity, but the smallest difference is stored in img_best, and corresponding disparity in img_disp. Both are input and output images.

  */
void vglFindDisparityDiff(VglImage* img_sum, VglImage* img_disp, VglImage* img_best, float disparity);

/** Calculate absolute difference between green channel of img_ref and img_2. Disparities considered are in the closed interval [4*disparity, 4*disparity+3].

    The four differences are stored in the RGBA image dst.

  */
void vglGreenDiffDisparity(VglImage* img_ref, VglImage* img_2, VglImage* dst, float disparity);

/** Apply homography in img_src and stores result in img_dst.

    Important: for matrices the cmponents are written in 
    column major order: 

    \c mat2 \c m = \c mat2 (1, 2, 3, 4)
\f$
    \Leftrightarrow
\f$
    \c m = 
\f$
    \left( 
      \begin{array}{cc}
          1  &  3        \\

          2  &  4
      \end{array}
    \right) 

\f$

    In C we build the matrix in line major order, then we must transpose
    tbe matrix before using it in OpenGL context.

  */
void vglHomography(VglImage* img_src, VglImage* img_dst, float* f_homo);

/** Convert depth map to affine reconstruction

    This algorithm ignores the infinite homography.

    img_map: input depth map

    img_3d: output reconstruction

    f: focal length in pixels

    b: baseline in cm

    D: fixation point or maximum depth

    is_float: if true, output image will store z in cm. If false
              output image will store z as 255 * (depth / D). 
              if depth == D then z = 0.

    disp_k: If set, single disparity will be used.

    h: height of camera in cm
 */
void vglMapTo3D(VglImage* img_map, VglImage* img_3d, float f, float b, float D, float disp_k= 0.0, float h= 10.0);

/** Mean of pixel values of levels of detail in [0, max_lod]. Result is stored in img_out.


  */
void vglMeanMipmap(VglImage* img_dif, VglImage* img_out, float max_lod);

/** Mean filter with a 3x3 square mask.

  */
void vglMeanSq3(VglImage* img_dif, VglImage* img_out);

/** Undistort, correct projection and rectify img_src and stores result in img_dst, for use with stereo algorithm

    The input float array f_dist contains the coefficient of radial distortion, and f_proj contains the intrinsinc parameters of the camera: center of projection (x and y); focal length in pixels (x and y). The focal lengths are the same when the pixels are square.

    The input float array f_homo contains the homography that rectifies the image.

    Important: for matrices the cmponents are written in 
    column major order: 

    \c mat2 \c m = \c mat2 (1, 2, 3, 4)
\f$
    \Leftrightarrow
\f$
    \c m = 
\f$
    \left( 
      \begin{array}{cc}
          1  &  3        \\

          2  &  4
      \end{array}
    \right) 

\f$


    In C we build the matrix in line major order, then we must transpose
    tbe matrix before using it in OpenGL context.

  */
void vglRectify(VglImage* img_src, VglImage* img_dst, float* f_dist, float* f_proj, float* f_homo);

/** VglSumDiff

    Sum of differences

  */
void vglSumDiff(VglImage* img_dif, VglImage* img_out);

/** VglSumDiffMipmap

    Sum of differences

  */
void vglSumDiffMipmap(VglImage* img_dif, VglImage* img_out, float max_lod);

/** Correct camera lens distortion of img_src and stores the result in img_dst.

    The input float array f_dist contains the coefficient of radial distortion, and f_proj contains the intrinsinc parameters of the camera: center of projection (x and y); focal length in pixels (x and y). The focal lengths are the same when the pixels are square.

    Reference:

    http://www.cognotics.com/opencv/docs/1.0/ref/opencvref_cv.htm#cv_3d

  */
void vglUndistort(VglImage* img_src, VglImage* img_dst, float* f_dist, float* f_proj);

